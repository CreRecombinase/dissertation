#+TITLE: Functional Enrichment by Expectation Maximization Project
#+SETUPFILE: setup.org
#+OPTIONS: toc:2

* TODO find immune genes
* TODO FGEM Project [0%]
** TODO Write Paper [0%]
   DEADLINE: <2020-05-13 Wed>
+ Target submission to Bioinformatics
*** TODO figures
**** TODO figure for workflow
**** TODO figure for validation
**** TODO figure for specific genes
**** DONE table of full results
***** DONE each feature and beta, univariate p value and beta
***** DONE each gene BF functional and uniform prior (and pathways) and evidence of the gene
*** TODO Introduction 
*** TODO Statistical Method 
*** Application to Cancer
*** TODO Software
*** TODO Results 
*** TODO Discussion
** TODO Analyses [53%]
   DEADLINE: <2020-05-04 Mon>
*** DONE Run FGEM on driverMAPS TCGA
*** TODO make plots 
*** DONE compare to univariate results
*** DONE plot of fisher exact test
*** TODO check against siming's results
*** TODO find (top) innate immune response
*** DONE do cross validation of FGEM
*** DONE show performance as a function of lambda
*** TODO double check with Siming
**** Multivariate enrichment
*** DONE number of (significant) genes per cancer
*** DONE find out what the outliers are
*** TODO filter to 20 genes for gene ontology
*** TODO choose a cancer to present


* Analysis


*** HNSC
*** UCEC 
*** BRCA

* TODO Display items [33%]
** TODO overall workflow
*** Input/output
*** univariate test
*** feature selection
*** enrichment and posterior
** DONE Univariate Enrichment features
*** biplot
*** FET results side by side with FGEM
**** for discrepant result show how fgem did better
**** highlight pathways where we show difference
** TODO Posterior figures [50%]
*** DONE UCEC and BRCA
*** TODO get rid of low functional posterior labels
** Genes
*** Heatmap
*** BRCA and UCEC
*** new genes that aren't characterized in this cancer type
*** new genes that aren't characterized in any cancer type

** Which cancer types are we going to look at ?

Some cancer types have weird bayes factors, so we're going to ignore those. That leaves us with these:

#+NAME: cancerlist
| cancer |
|--------|
| BLCA   |
| BRCA   |
| CESC   |
| ESCA   |
| GBM    |
| HNSC   |
| KIRC   |
| KIRP   |
| LIHC   |
| LUAD   |
| LUSC   |
| PAAD   |
| PRAD   |
| SARC   |
| SKCM   |
| TGCT   |
| UCEC   |
| UCS    |

#+PROPERTY: header-args:R  :var cancerlist=cancerlist
#+PROPERTY: header-args:R  :colnames yes

**** Looking at the data
We'll start by reading the data, pulling out the info we'll use, and saving it back in a nicer format.  We'll
also remove the olfactory receptor genes and siming's blacklisted genes
#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/  :results none

  library(tidyverse)
  library(fgem)
  library(qs)

  data_f <- fs::dir_ls("data/driverMAPS_results_20TumorTypes",glob="*txt")
  cancer_t <- str_replace(data_f, ".+/([A-Z]+)_BayesFactorFDR.txt", "\\1")
  blacklist_url <- "https://szhao06.bitbucket.io/driverMAPS-documentation/data/Blacklist_combined.txt"
  blacklist_df <- read_tsv(blacklist_url,col_names=c("cancer","Gene"))
  go_df <- select(BPGOdf, Gene, feature_name = feature)

  olfactory_df <- filter(go_df,feature_name=="GO:0050911") %>%
    select(Gene) %>%
    mutate(ina=NA) %>% 
    inner_join(tibble(cancer=cancer_t,ina=NA)) %>% select(-ina)
  blacklist_df <- bind_rows(olfactory_df,go_df) %>% distinct()
#+END_SRC

#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/  :results none

#+END_SRC

#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/  :results none
  vc <- readr::cols(
                 Gene = col_character(),
                 No_nonsyn = col_skip(),
                 functypecode8 = col_skip(),
                 mycons = col_skip(),
                 sift = col_skip(),
                 phylop100 = col_skip(),
                 MA = col_skip(),
                 No_unique_mutation = col_skip(),
                 TSG_BF = col_double(),
                 OG_BF = col_double(),
                 Expected_syn = col_skip(),
                 No_syn = col_skip(),
                 BF = col_double(),
                 predtag = col_skip(),
                 Posterior = col_skip(),
                 FDR = col_double()
               )

  cancer_df <- map2_df(data_f,
                       cancer_t,
                       ~vroom::vroom(.x,
                                     col_names = names(vc$cols),
                                     col_types = vc,
                                     skip = 1L) %>% mutate(cancer = .y))
  good_cancer_df <- anti_join(cancer_df,blacklist_df)
#+END_SRC

#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/  :results none

saveRDS(good_cancer_df,"data/cleanest_driverMAPS_results_20TumorTypes.RDS")
qs::qsave(good_cancer_df,"data/cleanest_driverMAPS_results_20TumorTypes.qs")

#+END_SRC

**** Check for negative intercept

We want to make sure that the intercept is negative.  We'll focus on cancers where that's the case

#+BEGIN_SRC R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 

    library(fgem)
    library(dplyr)

    cancer_df <- qs::qread("data/cleanest_driverMAPS_results_20TumorTypes.qs")  
    cancer_null <-  group_by(cancer_df,cancer) %>% 
    summarise(null_lik=fgem:::fgem_null_lik(BF, log_BF = TRUE),
              Intercept=fgem:::fgem_null(BF, log_BF = TRUE))

  filter(cancer_null,Intercept<0) %>% pull(cancer)
#+END_SRC

#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/  :results none

  saveRDS(cancer_df,"data/driverMAPS_results_20TumorTypes.RDS")
  qs::qsave(cancer_df,"data/driverMAPS_results_20TumorTypes.qs")
#+END_SRC


#+BEGIN_SRC R :colnames yes :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
head(cancer_df)
#+END_SRC

#+RESULTS:
| Gene   |            TSG_BF |             OG_BF |               BF | FDR | cancer |
|--------+-------------------+-------------------+------------------+-----+--------|
| PIK3CA | -1.77971729131923 |  322.833185837287 | 322.140038656727 |   0 | BLCA   |
| FGFR3  |  28.0895429320585 |  246.567548311336 | 245.874401130776 |   0 | BLCA   |
| TP53   |  191.788256479794 |  70.7692247503828 | 191.095109299234 |   0 | BLCA   |
| ERBB2  |  2.30809843606858 |  111.697583835288 | 111.004436654728 |   0 | BLCA   |
| ERCC2  |  14.6298592310469 |   80.657307268368 | 79.9641600878081 |   0 | BLCA   |
| ARID1A |  71.9813145469098 | -11.8163792581274 | 71.2881673663499 |   0 | BLCA   |


driverMAPS reports the $\text{BF}$'s as $log(\text{BF})$.  I haven't figured out a way to work with these values without 
exponentiating them and some of them are really big(small).  I'm going to have to "clamp" them between the minimum and maximum representable values
(using double precision floating point).  

**** GO terms

I'm going to pull the GO annotations from the ~GO.db~ package.



#+BEGIN_SRC R :session bioc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :results none :var cancerlist=cancerlist
  library(tidyverse)
  library(fgem)
  library(GO.db)
  library(qs)
  cancerf <- c("BLCA", "BRCA", "CESC", "ESCA", "GBM", "HNSC", "KICH", 
                   "KIRC", "KIRP", "LIHC", "LUAD", "LUSC", "PAAD", "PRAD", "SARC", 
                   "SKCM", "UCEC", "UCS")

#+END_SRC

#+BEGIN_SRC R :session bioc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :results none

  cancer_df <- qread("data/cleanest_driverMAPS_results_20TumorTypes.qs")
  tbp <- topGO::annFUN.org("BP",feasibleGenes=unique(cancer_df$Gene),mapping="org.Hs.eg.db",ID="symbol")
  tbp_df <- imap_dfr(tbp,function(Genes,GO)tibble(Gene=Genes,feature_name=GO))
  qs::qsave(tbp_df,"data/GO_df.qs")

#+END_SRC


#+BEGIN_SRC R :session bioc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :results none
  term_list <- as.list(GOTERM)    
  fn_df <- distinct(tbp_df,feature_name) %>% 
    pull(feature_name) %>% map_dfr(function(x){
      tx <- term_list[[x]]
      tibble(feature_name=x,
             Term=Term(tx),
             Definition=Definition(tx),
             Synonyms=list(Synonym(tx)))
    })
  qs::qsave(fn_df,"data/GO_Definitions.qs")
#+END_SRC

**** Fitting  Fisher's Exact test

#+BEGIN_SRC R :session fisher :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
  library(tidyverse)
  library(fgem)
  library(progressr)
  library(furrr)
  library(qs)
  plan(multisession)

  cancer_df <- qs::qread("data/cleanest_driverMAPS_results_20TumorTypes.qs") 
  BPGOdf <- qs::qread("data/GO_df.qs")
  min_cancer_df <- cancer_df %>%
  select(Gene, FDR, cancer)

  go_df <- mutate(BPGOdf,Gene=as.character(Gene)) %>%
  semi_join(distinct(cancer_df,Gene))

  go_df <- group_by(go_df,feature_name) %>%
    summarise(n_gt=n()) %>%
    filter(n_gt>=10) %>%
    select(feature_name) %>%
    inner_join(go_df)

  go_dfl <- nest(go_df,data=Gene) %>% mutate(isa=NA)
  cancer_dfl <- nest(min_cancer_df,fdr_data=c(Gene,FDR)) %>% mutate(isa=NA)

  fisher_inp <- inner_join(go_dfl,cancer_dfl,by="isa") %>% select(-isa) %>% mutate(ix=1:n())  %>% filter(cancer!="CHOL")
  with_progress({
    p <- progressor(along = fisher_inp$ix)
    fisher_df <- future_pmap_dfr(fisher_inp,function(cancer,feature_name,fdr_data,data,ix){
      p(sprintf("x=%g",ix))


      sig_gene <- fdr_data$FDR<0.2
      sig_feat <- fdr_data$Gene %in% data$Gene
ret_2 <- dplyr::mutate(broom::tidy(fisher.test(sig_gene,sig_feat)),feature_name=feature_name,cancer=cancer,cutoff=0.2)

      sig_gene <- fdr_data$FDR<0.1

ret_1 <- dplyr::mutate(broom::tidy(fisher.test(sig_gene,sig_feat)),feature_name=feature_name,cancer=cancer,cutoff=0.1)
      sig_gene <- fdr_data$FDR<0.05
ret_05 <- dplyr::mutate(broom::tidy(fisher.test(sig_gene,sig_feat)),feature_name=feature_name,cancer=cancer,cutoff=0.05)
      sig_gene <- fdr_data$FDR<0.01
ret_01 <- dplyr::mutate(broom::tidy(fisher.test(sig_gene,sig_feat)),feature_name=feature_name,cancer=cancer,cutoff=0.01)
return(bind_rows(ret_2,ret_1,ret_05,ret_01))
})
  })

  qs::qsave(fisher_df,"data/cleanest_single_fisher_cutoffs.qs")
#+END_SRC

#+RESULTS:

**** Fitting univariate models

     

#+BEGIN_SRC R :session univ :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
library(tidyverse)
library(fgem)
library(progressr)
library(stringr)
cancer_df <- qs::qread("data/cleanest_driverMAPS_results_20TumorTypes.qs")
#+END_SRC

#+BEGIN_SRC R :session remote_univ  :dir /ssh:rcc2|ssh:gardner:/home/t.cri.nknoblauch/data/
  library(future.batchtools)
   plan(list(
          tweak(batchtools_torque,
                template  = "/home/t.cri.nknoblauch/torque_batchtools.tmpl",
                resources = list(ncpus=10,mem=29000L,walltime=3600L*3)),multiprocess))
    #  plan(list(
    #    tweak(batchtools_slurm,
    #          template  = "/home/nwknoblauch/slurm_batchtools.tmpl",
    #          resources = list(ncpus=8,mem=19000L,walltime=3600L)),multiprocess))

#+END_SRC

#+BEGIN_SRC R :session univ :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :var cancerlist=cancerlist

  library(fgem)
  library(progressr)
  library(furrr)
  library(qs)
  cancerf <- dplyr::pull(cancerlist,cancer)
  plan(list(multisession))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session univ :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :var cancerlist=cancerlist


#+END_SRC

#+RESULTS:



#+BEGIN_SRC R :session univ :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
  BPGOdf <- qs::qread("data/GO_df.qs")
  nidf <-   nest(cancer_df,cdf=-cancer) %>% mutate(ix=1:n()) %>% 
  filter(cancer %in% cancerf)
  go_df <- mutate(BPGOdf,Gene=as.character(Gene)) %>%
    semi_join(distinct(cancer_df,Gene))

  go_df <- group_by(go_df,feature_name) %>%
    summarise(n_gt=n()) %>%
    filter(n_gt>=10) %>%
    select(feature_name) %>%
    inner_join(go_df)
  go_df <- mutate(go_df,value=1.0)
 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session univ :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
      fs::dir_create("data/fgem_cm_results/")
      fs::dir_create("data/fgem_cm_results_OG/")
      fs::dir_create("data/fgem_cm_results_TSG/")
      


  marg_fun <- function(cancer,cdf,ix){


        X <- fgem::trip2sparseMatrix(rowname_vals = as.character(go_df$Gene),
                                     colname_vals = go_df$feature_name,
                                     values = go_df$value,
                                     total_rownames = cdf$Gene,
                                     total_colnames = unique(go_df$feature_name),
                                     add_intercept = FALSE)



        fgmr_a <- dplyr::mutate(fgem:::fgem_marginal(X,cdf$BF,log_BF=TRUE,parallel=FALSE,grad=TRUE,hess=TRUE),cancer=cancer,cat="overall")
        qs::qsave(fgmr_a,fs::path("data/fgem_m_results/",cancer,ext="qs"))
        p(sprintf("x=%g",ix))
        return(fgmr_a)
        ## fgmr_og <- dplyr::mutate(fgem:::fgem_marginal(X,cdf$OG_BF,log_BF=TRUE,parallel=FALSE,grad=TRUE,hess=TRUE),cancer=cancer,cat="OG")
        ## qs::qsave(fgmr_og,fs::path("data/fgem_m_results_OG/",cancer,ext="qs"))

        ## fgmr_tsg <- dplyr::mutate(fgem:::fgem_marginal(X,cdf$TSG_BF,log_BF=TRUE,parallel=FALSE,grad=TRUE,hess=TRUE),cancer=cancer,cat="TSG")
        ## qs::qsave(fgmr_tsg,fs::path("data/fgem_m_results_TSG/",cancer,ext="qs"))
  #      return(dplyr::bind_rows(fgmr_a,fgmr_og,fgmr_tsg))
        }
    with_progress({
      p <- progressor(along = seq_len(nrow(nidf)))
      nidf %>% furrr::future_pmap_dfr(marg_fun) %>% 
      qs::qsave("data/alt_newest_fgem_marginal_results.qs")
    })


#+END_SRC

#+RESULTS:


**** Analyzing univariate models

***** GO


#+BEGIN_SRC R :session jacc  :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :var cancerlist=cancerlist
  library(fgem)
  library(dplyr)
  library(tidyr)
  library(purrr)
  library(Matrix)
  library(ggplot2)
  cancer_df <- qs::qread("data/cleanest_driverMAPS_results_20TumorTypes.qs")   %>% semi_join(cancerlist)
  cancer_null <-  group_by(cancer_df,cancer) %>% summarise(null_lik=fgem:::fgem_null_lik(BF,log_BF=TRUE),Intercept=fgem:::fgem_null(BF,log_BF=TRUE))
#+END_SRC


#+BEGIN_SRC R :session jacc  :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  fgem_df <- qs::qread("data/alt_newest_fgem_marginal_results.qs") %>%
    group_by(cancer) %>%
    mutate(qval = p.adjust(dplyr::if_else(convergence == 0, pval, 1), method = "fdr")) %>%
    ungroup() %>%
    mutate(hess_det=map_dbl(Beta,~det(.x$hessian)))


  sig_feat_df <- filter(fgem_df, qval < 0.2)
  sig_feat_df <- mutate(sig_feat_df,
                        term = map_chr(Beta,~.x$feature_name[2]),
                        Beta = map(Beta, ~mutate(.x, fisher = solve(hessian)))) %>%
    unnest(Beta)  %>%
    select(Beta, feature_name, fisher, hess_det, term, pval, qval, cancer) 


  curv_df <- sig_feat_df %>%
    group_by(term,cancer) %>%
    summarise(sd_intercept = fisher[1,1],
              sd_beta = fisher[2,2],
              Intercept = Beta[1],
              Beta = Beta[2],
              hess_det = hess_det[1],
              pval = pval[1],
              qval = qval[1]) %>%
    mutate(l_beta = qnorm(0.01, mean = Beta, sd = sqrt(sd_beta)),
           h_beta = qnorm(0.99, mean = Beta, sd = sqrt(sd_beta))) %>%
    ungroup()

  nsig_df <- filter(curv_df, sign(l_beta)==sign(Beta)) %>%
    mutate(gene_prior = plogis(Beta + Intercept)) %>%
    arrange(desc(gene_prior))


    GO_def <- readRDS("data/GO_Definitions.RDS") %>% select(feature_name,Term)
  high_prior_features <- filter(nsig_df,gene_prior>0.4) %>% arrange(Beta) %>% rename(feature_name=term)

  qs::qsave(high_prior_features,"data/high_prior_features.qs")


  low_prior_sig_features <- filter(nsig_df,gene_prior<=0.4) 
  notsig_df <- filter(curv_df, l_beta < 0) %>%
    arrange(desc(Beta))

#+END_SRC



#+BEGIN_SRC R :session jacc  :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 

  ody <- fs::path("data/new_conservative_y_models")
  fs::dir_create(ody)
  odx <- fs::path("data/new_conservative_x_models")

  go_df <- select(BPGOdf, Gene, feature_name = feature) %>% 
    mutate(Gene=as.character(Gene))
  genelist_go <- nest(go_df, gene_l = Gene) %>% 
    mutate(gene_l = map(gene_l, "Gene"))  %>%
    inner_join(select(low_prior_sig_features, feature_name= term, cancer))
  cancer_df <- qs::qread("data/cleanest_driverMAPS_results_20TumorTypes.qs") %>%
    select(Gene, BF, cancer)

  cancer_genes <- cancer_df %>% select(Gene,cancer) %>%
    nest(cancer_genes=Gene) %>% mutate(cancer_genes=map(cancer_genes,"Gene"))

  go_list_dfl <- genelist_go %>% 
    inner_join(cancer_genes,by="cancer") %>%
    mutate(gene_l = map2(gene_l, cancer_genes, ~factor(.x[.x %in% .y], levels = .y)),
                         n_genes = lengths(gene_l)) %>%
    select(-cancer_genes)

  x_mats <- split(go_list_dfl,go_list_dfl$cancer) %>% purrr::map(function(x){
    tdf <- unnest(x,gene_l)
    trip2sparseMatrix(as.character(tdf$gene_l),tdf$feature_name,total_rownames=levels(tdf$gene_l),add_intercept=FALSE)
  })
  x_mats <- x_mats[order(map_int(x_mats,NCOL))]
  yl <- split(cancer_df,cancer_df$cancer)
  yl <- yl[names(x_mats)]


  fs::dir_create(odx)
  iwalk(x_mats,function(x,y){
  qs::qsave(x,fs::path(odx,y,ext="qs"))
  })
  iwalk(yl,function(x,y){
  qs::qsave(x,fs::path(ody,y,ext="qs"))
  })
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session jacc  :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
rsync::rsynccli(odx,"gardner2:xm/data")
rsync::rsynccli(ody,"gardner2:xm/data")
#+END_SRC

#+RESULTS:
| x |
|---|
| 0 |





***** GO Only


**** Comparing univariate models to Fisher's Exact results

#+BEGIN_SRC R :session jacc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 

    library(dplyr)
    library(purrr)
    library(fgem)
    library(ggplot2)
    library(tidyr)

    cancer_df <- qs::qread("data/cleanest_driverMAPS_results_20TumorTypes.qs")
    bp_name <- readRDS("data/GO_Definitions.RDS") 
    cancer_df <- qs::qread("data/cleanest_driverMAPS_results_20TumorTypes.qs")   %>% semi_join(cancerlist)
    cancer_null <-  group_by(cancer_df,cancer) %>% summarise(null_lik=fgem:::fgem_null_lik(BF,log_BF=TRUE),Intercept=fgem:::fgem_null(BF,log_BF=TRUE))
#+END_SRC

#+RESULTS:




#+BEGIN_SRC R :session jacc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 

  fgem_results <- qs::qread("data/alt_newest_fgem_marginal_results.qs") %>%
    group_by(cancer) %>%
    mutate(qval = p.adjust(dplyr::if_else(convergence == 0, pval, 1), method = "fdr")) %>%
    select(Beta,pval,qval,cancer)
    ## ungroup() %>%
    ## mutate(hess_det=map_dbl(Beta,~det(.x$hessian)))



    ## fgem_results <- map_df(fs::dir_ls("data/fgem_m_results"), qs::qread) %>%


    ##     inner_join(select(cancer_null,-Intercept)) %>%
    ##     mutate(pval=stats::pchisq(-2 * (null_lik - (lik)), df=1, lower.tail=F)) %>%
    ##     group_by(cancer) %>%
    ##   mutate(qval = p.adjust(dplyr::if_else(convergence == 0, pval, 1), method = "fdr")) %>%
    ##   select(Beta,pval,qval,cancer)


    fgem_results_df <- fgem_results %>%
      mutate(Beta=map(Beta,~dplyr::select(.x,Beta,feature_name))) %>%
      ungroup() %>% 
      mutate(tid = 1:n()) %>%
      unnest(Beta) %>%
      group_by(tid) %>%
      mutate(trait=feature_name[feature_name!="Intercept"]) %>%
      ungroup() %>% 
      mutate(feature_name = dplyr::if_else(feature_name == "Intercept", "Intercept", "estimate_fgem")) %>%
      spread(key = "feature_name", value = "Beta") %>%
      select(feature_name=trait,pval_fgem = pval, qval_fgem = qval,cancer,estimate_fgem,Intercept)
  

    fisher_df <- qs::qread("data/cleanest_single_fisher_cutoffs.qs") %>%
        dplyr::select(cancer,
                      feature_name,
                      pval = p.value,cutoff) %>%
      mutate(cutoff=paste0("pval_fisher_",stringr::str_replace(cutoff,"\\.","_")))%>% spread(key="cutoff",value="pval")

    single_df <- inner_join(fisher_df, fgem_results_df, by = c("cancer", "feature_name"))
    qs::qsave(single_df,"data/single_df.qs")
#+END_SRC

#+BEGIN_SRC R :session jacc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  library(forcats)
  library(ggsci)
  library(tidyverse)

  go_df <- select(BPGOdf, Gene, feature_name = feature) %>% 
    mutate(Gene=as.character(Gene))

  intogen_df <- qs::qread("data/intogen_df.qs") %>%
    unnest(intogen_l) %>% mutate(is_intogen=TRUE)

  single_df <-     qs::qread("data/single_df.qs")
  GO_def <- readRDS("data/GO_Definitions.RDS") %>%
        select(feature_name,description=Term)
  sdf <- select(single_df,
                -qval_fgem,
                -estimate_fgem,
                -Intercept) %>%
    gather(key = "method",
           value = "pval",
           -cancer,
           -feature_name) %>%
    mutate(method = stringr::str_remove(method, "pval_"),
           is_fisher = dplyr::if_else(stringr::str_starts(method, "fisher"),
                                      "fisher",
                                      "fgem")) %>%
    group_by(cancer, method) %>%
    mutate(qval = p.adjust(pval, method = "fdr")) %>%
    ungroup() %>%
    filter((is_fisher == "fisher" & (method == "fisher_0_1")) | is_fisher == "fgem")


  weird_fishers <- select(single_df,cancer,feature_name,fisher=pval_fisher_0_05,fgem=qval_fgem) %>% group_by(cancer) %>% mutate(fisher=p.adjust(fisher,method="fdr")) %>% ungroup() %>% filter(fisher<0.05) %>% arrange(desc(fgem)) %>% head() %>% inner_join(GO_def)

  weird_fgem <- select(single_df,cancer,feature_name,fisher=pval_fisher_0_05,fgem=qval_fgem) %>%
    group_by(cancer) %>%
    mutate(fisher=p.adjust(fisher,method="fdr")) %>%
    ungroup() %>%
    filter(fgem<0.05) %>%
    arrange(desc(fisher)) %>%
    inner_join(GO_def)

  wf_fisher <- slice(weird_fishers,2)
  wf_fgem <- filter(weird_fgem, fisher<1) %>%
    slice(2)
  gsea_df <- qs::qread("data/gsea.qs")
  single_gsea_df <- inner_join(gsea_df, single_df)

  gene_sets <- split(go_df$Gene,go_df$feature_name)

  ## tcancer <- filter(cancer_df,cancer==cancer[1])

  ## library(furrr)
  ## library(progressr)

  ## interruptor = function(FUN,args, time.limit, ALTFUN){
  ##   results <- NULL
  ##   results <- evalWithTimeout({FUN(args)},timeout=time.limit,onTimeout="silent")
  ##   if(is.null(results)){
  ##     results <- ALTFUN(args)
  ##   }
  ##   return(results)
  ## }
  ## plan(multiprocess)
  ## sub_fun <- function(cancer,data){
  ##     cancer_rank <- set_names(data$BF,data$Gene)
  ##     fgr <- fgsea::fgsea(gene_sets,cancer_rank,nproc=1)
  ##     progress(amount=1)
  ## as_tibble(fgr) %>% select(feature_name=pathway,pval_gsea=pval,qval_gsea=padj,gsea_estimate=ES) %>% mutate(cancer=cancer)
  ##   }

  #cdfl <- nest(cancer_df,data=-cancer)
  ## with_progress({
  ##   progress <- progressor(steps=nrow(cdfl))
  ##   fgr_f  <- pmap(cdfl,function(cancer,data){
  ##     future(sub_fun(cancer,data))
  ##   })
  ## })

  ## fgr_f <- fgr_f[map_lgl(fgr_f,resolved)]
  ## fgr_df <- map_df(fgr_f,value)
  ## qs::qsave(fgr_df,"data/gsea.qs")

  ## cdfl_l <- pmap(cdfl, function(cancer, data) {
  ##   set_names(data$BF, data$Gene)
  ## })

  ## cdfl_l <- set_names(cdfl_l,cdfl$cancer)

  generate_dist_plot <- function(wf,nc=1){
    plotdf <- left_join(
      semi_join(cancer_df, wf),
      (left_join(wf, go_df))) %>%
      arrange(BF) %>%
      mutate(feature = if_else(is.na(feature_name), "Background", feature_name),
             is_sig_gene = if_else(FDR<0.05, "FDR<0.05", "FDR>=0.05"),
             idx = 1:n(),
             category = factor(interaction(feature,is_sig_gene)),
             sig_cat=gl(nc,ceiling(n()/nc),n())) %>%
      mutate(is_sig_gene = fct_reorder(factor(is_sig_gene),BF),
             category = fct_reorder2(category,feature!="Background",-BF),
             feature=factor(feature))
    isp_df <- filter(plotdf, feature != "Background") #%>% mutate(sh=124)
  
    plt <- plotdf %>%
      ggplot(aes(x=idx, y=BF, col=category, size=feature)) + geom_point() +
      xlab("Index") +
      ylab("LBF") +
      ggtitle(glue::glue_data(wf,"{cancer} {feature_name}: {description}"),
              glue::glue_data(wf,"fisher q-value: {fisher}\nFGEM q-value: {fgem}")) +
      scale_size_manual(values=c(1,2)) +
      geom_point(data=isp_df,aes(x=idx,y=BF),shape=124,size=9)+scale_color_uchicago()
    if(nc>1)
      plt <- plt+facet_wrap(~sig_cat,scales="free",nrow=1)
    return(plt)
  }

  swfg <- semi_join(single_df,wf_fgem) %>% as.data.frame()
  new_prior <- rep(stats::plogis(swfg$Intercept+swfg$estimate_fgem,log.p=TRUE),nrow(plotdf))

  trng <- range(plotdf$BF)
  rangesq <- seq(trng[1],trng[2],length.out=nrow(plotdf))
  all_with_model <- mutate(plotdf,
                           post_feature = c(fgem::BF2posterior(BF, Gene, new_prior, log_BF = TRUE)),
                           post_nf = c(fgem::BF2posterior(BF, Gene, fgem:::predict_uniform_prior(BF, log_BF = TRUE), log_BF = TRUE))) %>%
    select(Gene, BF, functional=post_feature,uniform=post_nf,idx,is_sig_gene,feature) %>%
    gather("model","posterior",functional,uniform)
  awm <- filter(all_with_model,feature!="Background")
  ggplot(all_with_model,aes(x=idx,y=posterior,col=model))+geom_point()+geom_point(data=awm,aes(x=idx,y=posterior,col=model),shape=124,size=9)

  plot_fisher <- generate_dist_plot(wf_fisher,3)
  plot_fgem <- generate_dist_plot(wf_fgem,5)


  sdf_sig <- group_by(sdf, cancer, feature_name, method) %>%
    summarise(sig = all(qval < 0.05)) %>%
    spread(key = method, value = sig) %>%
    ungroup() %>%
    rename(fisher = fisher_0_1) %>%
    filter(fgem | fisher) %>%
    inner_join(GO_def)

  sdf_b  <- select(sdf, -is_fisher, -qval)
  sdfc <-  sdf %>%
    summarise(proportion_significant=mean(qval<0.05)) %>%
    ungroup()


  group_by(sdf_sig,feature_name,method) %>%
    summarise(p_shared=mean(sig),n=n()) %>%
    arrange(desc(p_shared)) %>%
    group_by(method) %>%
    summarise(p_share=sum(p_shared>0),n=n())
    ggplot(aes(x=method,y=p_shared,fill=method)) + geom_boxplot()+scale_y_log10()

  cancer_it <- left_join(cancer_df,intogen_df) %>%
    replace_na(list(is_TCGA=FALSE,is_intogen=FALSE))
  sovdf <- inner_join(filter(sdf_sig,sig),go_df) %>% inner_join(cancer_it)
  ## fgem_not_fisher <- filter(sdf_sig,fgem,!fisher) %>%
  ##   inner_join(go_df) %>%
  ##   left_join(cancer_it)
  ## fisher_not_fgem <- filter(sdf_sig,!fgem,fisher) %>% inner_join(go_df) %>% left_join(cancer_it)
  sovdf <- group_by(ovdf,cancer,feature_name) %>% filter(sum(sig)<2) %>% ungroup() 

  group_by(sovdf,cancer,feature_name,method) %>%
    summarise(p_intogen=mean(is_intogen),
              p_tcga=mean(is_TCGA),
              p_external=mean((is_intogen & !is_TCGA)),
              mean_LBF=mean(BF)) %>% mutate(cancer = fct_reorder(cancer, -mean_LBF)) %>% 
    ggplot(aes(x=cancer,y=mean_LBF,index=method,fill=method)) + geom_boxplot()+scale_fill_uchicago() 

  fgem_not_fisher_v <- group_by(sdf_sig,
                                cancer,
                                feature_name) %>%

    ungroup() %>%
    mutate(class="fgem_not_fisher")

  fisher_not_fgem_v <- group_by(fisher_not_fgem,
                                cancer,
                                feature_name) %>%
    summarise(p_intogen=mean(is_intogen),
              p_tcga=mean(is_TCGA),
              p_external=mean((is_intogen & !is_TCGA)),
              mean_LBF=mean(BF)) %>%
    ungroup()  %>%
    mutate(class="fisher_not_fgem")

  ovdf <- bind_rows(fgem_not_fisher_v,fisher_not_fgem_v) #%>% group_by(cancer,feature_name,
  group_by(ovdf,class) %>%
    summarise(pt_intogen=mean(p_intogen>0),
              pt_tcga=mean(p_tcga>0),
              pt_external=mean(p_external>0),
              tot_feat=n()) %>%
    ungroup() 
            
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session jacc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  fisher_fgem_dat <- select(single_df,cancer,feature_name,contains("pval")) %>% 
    gather(key="method",value="pval",contains("pval"))  %>% distinct()  %>%  group_by(cancer,method) %>%
    mutate(qval=p.adjust(pval,method="fdr")) %>% summarise(n_sig=sum(qval<0.01))  %>% group_by(cancer) %>%
    filter(all(n_sig>0)) %>%
    ungroup() %>% mutate(is_fgem=stringr::str_detect(method,"fgem"),method=stringr::str_remove(method,"pval_"))
  fisher_plt <-  fisher_fgem_dat%>%
    ggplot(aes(x=cancer,y=n_sig,fill=method))+geom_bar(stat="identity",position="dodge")+ggtitle("Number of significant (qval<0.01) features","Fisher at various FDR thresholds") 
  ggsave("org/fgem_fisher.png",plot=fisher_plt)

  wgdf <- select(single_df,cancer,feature_name,fisher=pval_fisher,fgem=pval_fgem) %>% 
    gather(key="method",value="pval",fisher,fgem)  %>% distinct() %>% group_by(cancer,method) %>%
    mutate(qval=p.adjust(pval,method="fdr")) %>% filter(cancer=="LIHC") %>%
    ungroup() %>% select(-pval) %>% 
    spread(method,qval) %>%
    filter(fisher<0.01,fgem>=0.01)


  filter(bp_name,feature_name== "GO:0000122") %>% unnest(Synonyms)


  BPGOdf <- qs::qread("data/GO_df.qs")
  min_cancer_df <- cancer_df %>%
    select(Gene, BF, cancer) %>%
    mutate(BF = exp(BF))

    go_df <- mutate(BPGOdf,Gene=as.character(Gene)) %>%
      semi_join(distinct(cancer_df,Gene))

    go_df <- group_by(go_df,feature_name) %>%
      summarise(n_gt=n()) %>%
      filter(n_gt>=10) %>%
      select(feature_name) %>%
      inner_join(go_df)
  go_df <- mutate(go_df,value=1.0)

  wcdf <- filter(cancer_df,cancer=="LIHC")
                         
  ixdf <- semi_join(go_df, wgdf)

  cX <- fgem::trip2sparseMatrix(rowname_vals = as.character(ixdf$Gene),
                                     colname_vals = ixdf$feature_name,
                                     values = ixdf$value,
                                     total_rownames = wcdf$Gene,
                                     total_colnames = unique(ixdf$feature_name),
                                add_intercept = FALSE)
  BF <- wcdf$BF
  fgmr <- fgem_marginal(cX,BF,log_BF=TRUE)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session jacc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :results graphics :file org/fisher_fgem.png
ggplot(single_df,aes(x=pval_fisher,y=pval_fgem))+geom_point()+geom_abline(slope=1)+facet_wrap(~cancer)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session jacc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
ggs <- filter(single_df,1-pval_fisher>.Machine$double.eps) %>% ggplot(aes(x=pval_fisher,y=pval_fgem))+geom_point()+facet_wrap(~cancer,scales="free")+scale_x_log10()+scale_y_log10()+geom_smooth(method="lm")+geom_abline(slope=1)+ggtitle("Fisher's Exact Test vs FGEM p-values")
ggsave("org/fisher_fgem.png",plot=ggs)
#+END_SRC

**** Fitting Multivariate models


***** GO only



#+BEGIN_SRC R :session *shell* 
library(dplyr)
library(purrr)
library(fgem)
library(tidyr)
library(dplyr)
library(progressr)
library(future.apply)
#+END_SRC

#+BEGIN_SRC R :session *shell* :dir /ssh:gardner2:/home/nwknoblauch/xm
  library(future.batchtools)
  plan(list(
    tweak(batchtools_torque,
          template  = "/home/t.cri.nknoblauch/torque_batchtools.tmpl",
          resources = list(ncpus=10,mem=29000L,walltime=3600L*3)),multiprocess))
#+END_SRC



#+BEGIN_SRC R :session fitmult :dir /ssh:gardner2:/home/nwknoblauch/xm

  #plan(multisession)
  plan(list(tweak(multisession,workers=4),multicore))
#+END_SRC

#+BEGIN_SRC R :session fitmult :dir /ssh:gardner2:/home/nwknoblauch/xm
  out_d <- fs::path("data/new_cv_gobp_models_conservative_relaxed/")
  fs::dir_create(out_d)
  fs::dir_delete(out_d)
  fs::dir_create(out_d)

  ody <- fs::path("data/new_conservative_y_models")
  odx <- fs::path("data/new_conservative_x_models")
  ct <- fs::path_ext_remove(fs::path_file(fs::dir_ls(odx)))
  opf <- purrr::map_chr(ct,~fs::path(out_d,.x, ext="qs"))
  ct <- ct[!file.exists(opf)]
  iseq <- seq_along(ct)

  sub_fun <- function(tf, cancerf, od){
    cancer <- cancerf[tf]
    #p(sprintf("i=%g", tf))
    op <- fs::path(od,cancer, ext="qs")
    if(!file.exists(op)){
      ym <- qs::qread(fs::path(ody, cancer, ext = "qs"))
      X <- qs::qread(fs::path(odx, cancer, ext = "qs"))
  #    with_progress({
      cv_df <- dplyr::mutate(fgem:::cv_relax_fgem(X, ym$BF, alpha=0.95, stratify_BF = FALSE, grad=TRUE, hess=TRUE, log_BF = TRUE), cancer = cancer)
                                          #   })
      ## with_progress({
      ##   ccv_df <- dplyr::mutate(cv_fgem(X,ym,alpha=0.8,stratify_BF=FALSE),cancer=cancer)
      ## })                                      
      qs::qsave(cv_df, op)
      return(cv_df)
    }else{
      return(qs::qread(op))
    }
  }
#+END_SRC

#+BEGIN_SRC R :session fitmult :dir /ssh:trcc:/home/nwknoblauch/xm

  with_progress({
    p <- progressor(along = iseq)  
    ret_df <- future.apply::future_lapply(iseq,sub_fun,cancerf=ct,od=out_d)
  })
  ret_df <- dplyr::bind_rows(ret_df)

#+END_SRC


**** Plotting multivariate models

     
** COSMIC census

From [[https://cancer.sanger.ac.uk/census][Cosmic:]]
#+BEGIN_QUOTE
The Cancer Gene Census (CGC) is an ongoing effort to catalogue those genes which contain mutations that have been causally implicated in cancer and explain how dysfunction of these genes drives cancer. The content, the structure, and the curation process of the Cancer Gene Census was described and published in Nature Reviews Cancer.

The census is not static, instead it is updated when new evidence comes to light. In particular we are grateful to Felix Mitelman and his colleagues in providing information on more genes involved in uncommon translocations in leukaemias and lymphomas. Currently, more than 1% of all human genes are implicated via mutation in cancer. Of these, approximately 90% contain somatic mutations in cancer, 20% bear germline mutations that predispose an individual to cancer and 10% show both somatic and germline mutations.
Census tiers

Genes in the Cancer Gene Census are divided into two groups, or tiers.
Tier 1

To be classified into Tier 1, a gene must possess a documented activity relevant to cancer, along with evidence of mutations in cancer which change the activity of the gene product in a way that promotes oncogenic transformation. We also consider the existence of somatic mutation patterns across cancer samples gathered in COSMIC. For instance, tumour suppressor genes often show a broad range of inactivating mutations and dominant oncogenes usually demonstrate well defined hotspots of missense mutations. Genes involved in oncogenic fusions are included in Tier 1 when changes to their function caused by the fusion drives oncogenic transformation, or in cases when they provide regulatory elements to their partners (e.g. active promoter or dimerisation domain).
Tier 2

A new section of the Census, which consists of genes with strong indications of a role in cancer but with less extensive available evidence. These are generally more recent targets, where the body of evidence supporting their role is still emerging.
Hallmarks

New overviews of cancer gene function focused on hallmarks of cancer pull together manually curated information on the function of proteins coded by cancer genes and summarise the data in simple graphical form. They present a condensed overview of most relevant facts with quick access to the literature source, and define whether a gene has a stimulating or suppressive effect via individual cancer hallmarks. Genes with the hallmark descriptions available are marked with the hallmark icon, that when clicked, opens the hallmark page. Hallmark descriptions will be expanded to encompass more genes and updated on regular basis. 

#+END_QUOTE

#+BEGIN_SRC R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :colnames yes
  library(broom)
  ccols <- cols(
    Gene = col_character(),
    Name = col_skip(),
    `Entrez GeneId` = col_skip(),
    `Genome Location` = col_skip(),
    Tier = col_integer(),
    Hallmark = col_character(),
    `Chr Band` = col_skip(),
    Somatic = col_factor(levels="yes"),
    Germline = col_factor(levels="yes"),
    SomaticTypes = col_character(),
    GermlineTypes = col_character(),
    `Cancer Syndrome` = col_skip(),
    `Tissue Type` = col_skip(),
    `Molecular Genetics` = col_skip(),
    `Role in Cancer` = col_skip(),
    `Mutation Types` = col_skip(),
    `Translocation Partner` = col_skip(),
    `Other Germline Mut` = col_skip(),
    `Other Syndrome` = col_skip(),
    Synonyms = col_skip()
  )
  cancer_census <- readr::read_csv("data/cancer_gene_census.csv",col_names=names(ccols$cols),col_types=ccols,skip=1L) %>% 
  mutate(is_census=TRUE)

  GO_def <- readRDS("data/GO_Definitions.RDS") %>% select(feature_name,Term)
  GO_def <- bind_rows(GO_def,tibble(feature_name="Intercept",Term="")) %>% distinct()
  out_d <- fs::path("data/fdr_models/")

  all_results <- map_df(fs::dir_ls(out_d),qs::qread) %>%
      select(-term)

  all_results_df <- all_results  %>%
      unnest(data)  %>%
      inner_join(GO_def) %>%
      mutate(label=paste0(feature_name,":\n",Term))




  gen_go_mat <- function(datadl,cancer,cancer_list){
    xm <- qs::qread(fs::path("data/x_models/",cancer,ext="qs"))
    stopifnot(all(datadl$feature_name %in% colnames(xm)))
    x <- xm[,datadl$feature_name,drop=FALSE]
    cancer_vec <- rownames(xm) %in% cancer_list
    odf <- as_tibble(x) %>% mutate(cl=as.integer(cancer_vec))
    broom::tidy(glm(cl~.+0,data=odf,family=binomial())) %>%
      rename(feature_name=term)
  }


logit_df <- map2_dfr(all_results$data,all_results$cancer,gen_go_mat,cancer_list=cancer_census$Gene) %>%
    select(cancer,feature_name,pval_fisher=p.value)

  fisher_df <- map2_dfr(all_results$data,all_results$cancer,gen_go_mat,cancer_list=cancer_census$Gene) %>%
    select(cancer,feature_name,pval_fisher=p.value)
  univ_assoc <- readRDS("data/fgem_data.RDS")  %>% select(cancer,feature_name=trait,pval_logit=pval) %>% 
    inner_join(select(fisher_df,cancer,feature_name,pval_fisher=p.value)) 


  filter(all_results_df,feature_name!="Intercept")
#+END_SRC

#+BEGIN_SRC R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :colnames yes
  library(fgem)
  library(tidyverse)

  log_pbinom <- function(lp,x){
      sum(x*lp+(1-x)*log(expm1(-lp)))
    }

  prior_post_plot <- function(datadl,cancer,log=TRUE,cancer_list){
    ym <- qs::qread(fs::path("data/y_models/",cancer,ext="qs"))
    xm <- qs::qread(fs::path("data/x_models/",cancer,ext="qs"))
    stopifnot(all(datadl$feature_name %in% colnames(xm)))
    x <- xm[,datadl$feature_name,drop=FALSE]
    unifp <- fgem:::gen_u(fgem:::fgem_null(ym),x[,"Intercept",drop=FALSE],ym,log=log)
                                          #unifp <- fgem:::prior_mean(BF,log=log)
    cancer_vec <- rownames(x) %in% cancer_list
    fp <- fgem:::gen_u(datadl$Beta,x,ym,log=log)
    tibble(cancer=cancer, cross_entropy_functional = -log_pbinom(fp,cancer_vec),
           cross_entropy_uniform = -log_pbinom(unifp,cancer_vec),
           cross_entropy_ratio=cross_entropy_functional-cross_entropy_uniform)
  }


#+END_SRC


** cross-validation

#+BEGIN_SRC R :session fg :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  library(tidyverse)
  #rsync::rsynccli("gardner2:xm/data/new_cv_gobp_models_conservative_relaxed", "data")
#+END_SRC

#+RESULTS:
| x |
|---|
| 0 |



#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
library(tidyverse)
library(fgem)
  file_n <- fs::dir_ls("data/new_cv_gobp_models_conservative_relaxed/")
  safe_r <- safely(qs::qread)
  fit_l <- map(file_n,safe_r) 
  fit_df <- map(fit_l,"result") %>% compact() %>% bind_rows() %>% group_by(cancer)

  fit_df <- map_df(file_n, qs::qread) %>%
    group_by(cancer)

    sfit_df <- fgem:::summarise_cv_lik(fit_df)
    sfit_df <- filter(sfit_df,l2==0) %>% 
  transmute(cancer=cancer,cv_sum0=cv_sum,l0mean0=l0_mean,l1mean0=l1_mean,l2mean0=l2_mean) %>% inner_join(sfit_df)
  sfit_df <- sfit_df %>% mutate(is_max_cv=cv_sum==max(cv_sum),max_l2=l2[is_max_cv])

  GO_def <- readRDS("data/GO_Definitions.RDS") %>%
      select(feature_name, description=Term)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 


  filter(sfit_df,l2>0) %>% 
  ggplot(aes(x=l2_mean,y=cv_sum)) +
    geom_point(aes(col=is_max_cv)) +
    facet_wrap(~cancer, scales = "free") +
    scale_x_log10()

  filter(sfit_df) %>%
    ggplot(aes(x=l2,y=cv_sum)) +
    geom_point(aes(col=is_max_cv)) +
    facet_wrap(~cancer, scales = "free") +
    geom_hline(aes(yintercept=cv_sum0)) +
    scale_x_log10()

  unnest(sfit_df,Beta) %>%
    group_by(cancer, l2, is_max_cv) %>%
    filter(feature_name!="Intercept") %>%
    summarise(max_abs_Beta=max(abs(Beta))) %>% filter(l2>0) %>% 
    ggplot(aes(x=l2,y=max_abs_Beta))+geom_point(aes(col=is_max_cv))+facet_wrap(~cancer,scales="free")+scale_x_log10()

  unnest(sfit_df,Beta) %>%
    filter(feature_name!="Intercept")  %>%
    filter(l2>0 | is_max_cv) %>%
    ggplot(aes(x=l2,y=Beta,col=feature_name))+geom_line()+scale_x_log10()+facet_wrap(~cancer,scales="free")+theme(legend.position = "none")+geom_vline(aes(xintercept=max_l2))
#+END_SRC

#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 

  sfit_df %>% 
    mutate(is_max_cv=cv_sum == max(cv_sum)) %>%
    filter(is_max_cv) %>%
    unnest(Beta)  %>%
    filter(Beta != 0) %>%
    filter(feature_name != "Intercept") %>% 
    filter(abs(Beta) == max(abs(Beta)))  %>%
    arrange(desc(abs(Beta)))  %>%
    inner_join(GO_def) %>%
    select(-is_max_cv) %>%
    as.data.frame()
#+END_SRC


*** Subsetting the best models


#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  library(tidyverse)
  library(fgem)
  library(ggrepel)
  library(patchwork)
  ocancer_df <- qs::qread("data/cleanest_driverMAPS_results_20TumorTypes.qs")
  tcancer_df <- ocancer_df %>%   select(Gene,cancer,BF) %>% filter(cancer==cancer[1])
  fgnf <- fgem:::fgem_null_fit(tcancer_df$BF,log_BF=TRUE)
  tpr <- fgem:::predict_fgem(fgnf,fgem:::empty_x(tcancer_df$BF,tcancer_df$Gene),log=TRUE)
  xb <- stats::qlogis(tpr,log.p=TRUE)
  tbf <- fgem:::log_BF2_logpost(tcancer_df$BF,xb)
  cancer_df <-  ocancer_df %>%
    select(Gene,cancer,BF) %>% 
    group_by(cancer) %>%
    mutate(uniform_posterior = c(BF2posterior(BF,Gene,prior=fgem:::predict_uniform_prior(BF,Gene,log_BF=TRUE),log_BF=TRUE)))

  all_genes <- unique(cancer_df$Gene)

  cancer_dfl  <-  group_nest(cancer_df,.key="data")



  go_df <- qs::qread("data/GO_df.qs")
  long_df <- bind_rows(go_df)
  blong_df <- bind_rows(
                        long_df,
                        tibble(Gene=all_genes,feature_name="Intercept"))
  all_def <- bind_rows(mutate(GO_def,category="GO",sub_category="BP"))
  xMS <- fgem:::df2sparse(long_df,total_rownames=all_genes)
#+END_SRC

#+RESULTS:


** IntOGen validation

An alternative source of validation is cite: cite:gonzalez-perez13_intog_mutat_ident_cancer_driver


#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 

  comp_df <- read_tsv("data/2020-02-02_IntOGen-Drivers-20200213/Compendium_Cancer_Genes.tsv") 
  cohort_df <- read_tsv("data/2020-02-02_IntOGen-Cohorts-20200213/cohorts.tsv") %>% mutate(is_TCGA=SOURCE=="TCGA")

  is_tcga <- select(cohort_df,cohort=COHORT,is_TCGA) %>% distinct()

  cohort_tcga <- filter(cohort_df,is_TCGA) %>%
    rename(cohort=COHORT) %>%
    mutate(cancer=str_remove(cohort,"TCGA_W.S_")) %>%
    select(intogen_cancer=CANCER_TYPE,cancer)
  #cohort_notcga <- filter(cohort_df,SOURCE!="TCGA") %>% rename(cohort=COHORT)

  sub_comp_df <- select(comp_df,Gene=SYMBOL,cohort=COHORT,intogen_cancer=CANCER_TYPE,qval_cons=QVALUE_COMBINATION) %>%
    inner_join(is_tcga) %>% 
    left_join(cohort_tcga) %>%
    mutate(cancer=if_else(is.na(cancer),intogen_cancer,cancer)) %>%
    select(-intogen_cancer)  %>%
    distinct(cancer,Gene,is_TCGA)


  intogen_l <- nest(sub_comp_df,intogen_l=-cancer)
qs::qsave(intogen_l,"data/intogen_df.qs")

#+END_SRC

#+RESULTS:


#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 

  assign_intogen <-  function(data,cancer,include_tcga=TRUE){
    if("intogen_gene" %in% colnames(data)){
      return(data)
      }
        if(!include_tcga){
          scdf <- filter(sub_comp_df,!is_TCGA)
        }else{
          scdf  <- sub_comp_df
        }
        intogen_l <- mutate(scdf,intogen_gene = if_else(cancer == {{cancer}},
                                                               if_else(is_TCGA, 2L, 1L),
                                                               if_else(is_TCGA, 4L, 3L))) %>%
            group_by(Gene) %>%
            summarise(intogen_gene=min(intogen_gene), .groups = "drop")
          rdf <- left_join(data, intogen_l, by="Gene") %>%
            replace_na(list(intogen_gene = 5L))  %>%
            group_by(Gene) %>%
            filter(intogen_gene==min(intogen_gene)) %>%
            slice(1) %>% 
            ungroup()
  return(rdf)
      }

      kt <- c("Known Type-Specific Cancer Gene (Non-TCGA)",
              "Known Type-Specific Cancer Gene (TCGA)",
              "Known Cancer Gene (Non-TCGA)",
              "Known Cancer Gene (TCGA)",
              "Unknown Cancer Gene")

      skt <- c("Type-Specific(Non-TCGA)",
              "Type-Specific(TCGA)",
              "Generic(Non-TCGA)",
              "Generic(TCGA)",
              "Unknown")
  igdf <- tibble(intogen_gene=1:5,
                 IntogenClass=skt) %>% mutate(
                                         TypeSpecific=str_detect(IntogenClass,"Type-Specific"),
                                         isCancer=intogen_gene<5,
                                         is_non_tcga=intogen_gene %in% c(1L,3L))


      group_mapn <- function(.x,.f,...){
        gv <- group_vars(.x)
        .x <- ungroup(.x)
        split(.x,.x[[gv]]) %>% map(.f=.f,...=...)
      }

    cancer_dfl <- nest(cancer_df,data=-cancer) %>% mutate(data=map2(data,cancer,assign_intogen,include_tcga=TRUE))
#+END_SRC

#+RESULTS:


*** Predictions from the best models

#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  add_pred <- function(beta_df,cancer_df,log=FALSE){
    ret_df <- mutate(cancer_df, functional_prior = c(fgem:::predict_long_df(beta_df, xMS[cancer_df$Gene,],log=log)),
                     functional_posterior=c(fgem:::BF2posterior(BF, Gene, functional_prior,log_BF=log)))
  }

  log_pbinom <- function(lp,x){
    lp <-   pmin(lp,-.Machine$double.eps)
    sum(x*lp+(1-x)*log(expm1(-lp)))
  }



#+END_SRC



#+RESULTS:



#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  library(firatheme)
    plot_post <- function(data,log=TRUE){

      pdata <-   filter(data
                       ) %>% arrange(desc(functional_posterior-uniform_posterior)) %>%
        mutate(idn=1:n(),
               `intOGen Validation Status`=factor(kt[intogen_gene],levels=kt))

      if(!log){
        pdata <- mutate(pdata,functional_posterior=exp(functional_posterior),
                        uniform_posterior=exp(uniform_posterior))
        fpc <- 1e-05
        fp <- 0.99
        sfp <- 0.9
      }else{
        fpc <- log(1e-05)
        fp <- log(0.99)
        sfp <- log(0.9)
      }
      
      top_diff <- filter(pdata,
                         functional_posterior>fpc) %>% slice(1:25)
      top_g <- filter(pdata, idn>=15, functional_posterior > fp | uniform_posterior > fp) %>%
        group_by(`intOGen Validation Status`) %>% arrange(desc(pmax(functional_posterior,uniform_posterior))) %>% slice(1:15) %>% ungroup()
      ttg <- filter(pdata,intogen_gene==5,functional_posterior > sfp)
      top_g <- bind_rows(top_g,ttg) %>% distinct()

      rp <- pdata %>%
        ggplot(aes(x=uniform_posterior,
                      y=functional_posterior,
                      col = `intOGen Validation Status`,
                      label=Gene)) + 
         geom_point() +
        geom_label_repel(data=top_diff,max.overlaps=10) +
        geom_label_repel(data=top_g,max.overlaps=10) +
        geom_abline(slope=1)


      return(rp)
    }


    plot_beta <- function(Beta, cancer){
      k <- 22
      tBeta <- filter(Beta, feature_name != "Intercept", Beta != 0)
      nr <- ceiling(nrow(tBeta)/k)
      BR <- range(tBeta$Beta)
      l <- nrow(tBeta)
      Beta_p <- tBeta %>% arrange(abs(Beta)) %>%
        mutate(label=str_wrap(paste0(feature_name,":\n",description),width=50),
               label=factor(label,levels=label),Beta_ct=gl(n=nr,k=k,length=l),
               feature_name=factor(feature_name,levels=feature_name),
               idx=1:n())
      ggplot(tail(Beta_p, k),
             aes(y = label, x = Beta)) +
        geom_point() +
        ggtitle(cancer)
    }


  plt_fun <- function(Beta, data, cancer, l0_mean,...){
    l0n <- l0_mean
    pta <- proc.time()
    out_png_e <- fs::path(paste0("org/conservative_","gobp","_enrichment"))
    fs::dir_create(out_png_e)
    out_png_p <- fs::path(paste0("org/conservative_","gobp","_posterior"))
    fs::dir_create(out_png_p)
    lout_png_p <- fs::path(out_png_p,paste0(cancer,"_log"),ext="png")
    out_png_p <- fs::path(out_png_p,cancer,ext="png")
  
    out_png_e <- fs::path(out_png_e,cancer,ext="png")
  
    pa <- plot_beta(Beta,cancer) + theme_fira() + plot_annotation(title=cancer,subtitle=paste0("L0: ",as.integer(l0n)))
    ggsave(out_png_e,pa,dpi=320,width=13.33,height=7.5)
  
    pb <- plot_post(data,log=FALSE) + theme_fira()+ plot_annotation(title=cancer,subtitle=paste0("L0: ",as.integer(l0n)))
    ggsave(out_png_p,pb,dpi=320,width=13.33,height=7.5)
    lpb <- plot_post(data,log=TRUE) + theme_fira()+ plot_annotation(title=cancer,subtitle=paste0("L0: ",as.integer(l0n)))
    ggsave(lout_png_p,lpb,dpi=320,width=13.33,height=7.5)
    return(proc.time()-pta)
  }
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  bf <- filter(sfit_df,is_max_cv) %>% 
    inner_join(cancer_dfl) %>%
    mutate(data=map2(Beta, data,add_pred,log=TRUE),
           Beta=map(Beta,inner_join,y=all_def,by="feature_name")) %>% 
    dplyr::mutate(data = map2(data, cancer, assign_intogen, include_tcga = TRUE))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
library(furrr)
plan(multisession)
future_pmap(bf,plt_fun)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  cancer_null <-  group_by(cancer_df,cancer) %>% summarise(null_lik=fgem:::fgem_null_lik(BF,log_BF=TRUE),Intercept=fgem:::fgem_null(BF,log_BF=TRUE))

  feat_df <- qs::qread("data/single_df.qs") %>% select(feature_name,
                                                       cancer,
                                                       univariate_p = pval_fgem,
                                                       fisher_p = pval_fisher_0_1,
                                                       univariate_q = qval_fgem)

  bfdf <- select(feat_df,cancer,feature_name,contains("fisher")) %>% gather(key="cutoff",value="pval",-cancer,-feature_name)

  group_by(bfdf,cancer,cutoff) %>% mutate(pa=p.adjust(pval,"fdr")) %>% group_by(cutoff) %>% summarise(n_sig=mean(pa<0.05)) %>% arrange(desc(n_sig))

  ## feat_df <- map_df(fs::dir_ls("data/fgem_m_results"), qs::qread) %>%
  ##   inner_join(select(cancer_null,-Intercept)) %>%
  ##   mutate(pval=stats::pchisq(-2 * (null_lik - (lik)), df=1, lower.tail=F)) %>%
  ##   group_by(cancer) %>%
  ##   mutate(qval = p.adjust(dplyr::if_else(convergence == 0, pval, 1), method = "fdr")) %>%
  ##   unnest(Beta) %>%
  ##   filter(feature_name != "Intercept") %>%
  ##   

#+END_SRC

#+RESULTS:
| cutoff   |              n_sig |
|----------+--------------------|
| fisher_p | 0.0125872956132648 |

#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/  :colnames yes
head(feature_odf)
#+END_SRC


#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 

    post_df <- unnest(select(bf,cancer,data),data) %>%
      mutate(functional_posterior=exp(functional_posterior),
             uniform_posterior=exp(uniform_posterior),
             post_ratio=functional_posterior/uniform_posterior,
             post_diff=functional_posterior-uniform_posterior,
             rank_diff=rank(functional_posterior)-rank(uniform_posterior)) %>% inner_join(igdf)
    pda <- post_df %>% group_by(cancer) %>% summarise(ave_diff_overall=mean(functional_posterior-uniform_posterior))
    ggplot(post_df,aes(x=cancer,y=rank_diff,col=cancer,fill=cancer))+
      facet_wrap(~IntogenClass,scales="free_y")+geom_violin()
    filter(post_df,is_non_tcga | !isCancer) %>% mutate(is_ooc=IntogenClass=="Type-Specific(Non-TCGA)") %>% 
      mutate(rank_unif = rank(uniform_posterior),
             rank_func = rank(functional_posterior),
             rank_diff = rank_func-rank_unif) %>%
      group_by(cancer,is_ooc) %>% 
      summarise(ave_diff=mean()) %>%
      spread(key="is_ooc",value="ave_diff") %>% arrange(desc(`TRUE`-`FALSE`)) 
      spread(key="intogen_gene",value="ave_diff") %>%
      write_tsv("data/posterior_diff.tsv")

    huge_bf <- unnest(select(bf,-data),Beta) %>%
      filter(Beta != 0) %>% 
      inner_join(blong_df) %>%
      inner_join(unnest(select(filter(bf), -Beta), data)) %>%
      mutate(intogen_gene=kt[intogen_gene])

  feature_odf <- unnest(select(bf, -data), Beta)  %>%
    filter(Beta != 0) %>%
      select(cancer, feature_name, Beta, category, sub_category, description) %>%
      inner_join(feat_df) %>%
      arrange(cancer, desc(abs(Beta)))
  BPGOdf <- select(BPGOdf,Gene,feature_name=feature)


  feature_odf <- inner_join(select(feature_odf, cancer, feature_name), BPGOdf) %>% 
    inner_join(cancer_df) %>%
    mutate(uniform_posterior = exp(uniform_posterior)) %>%
    group_by(cancer, feature_name) %>%
    summarise(num_genes = n_distinct(Gene),
              n_sig = sum(uniform_posterior > 0.9)) %>%
    inner_join(feature_odf)

  feature_odf %>%
    write_tsv("data/all_conservative_features.tsv")
#+END_SRC

#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  filter(huge_bf, Beta != 0) %>%
    filter(Beta < 0)

  w_bf <- distinct(huge_bf,Gene,cancer,BF,functional_prior,functional_posterior,uniform_posterior,intogen_gene) %>%
    mutate(uniform_posterior=exp(uniform_posterior),
           functional_posterior=exp(functional_posterior),
           functional_prior=exp(functional_prior)) %>%                                                             
    inner_join(
      filter(huge_bf,Beta!=0) %>% 
      group_by(cancer, Gene,intogen_gene) %>%
      summarise(features=paste0(feature_name,collapse=";"))) %>%
    arrange(cancer,desc(functional_posterior)) %>% 
    write_tsv("data/all_conservative_genes.tsv")

#+END_SRC

#+RESULTS:


** The case of GBM

GBM has a feature with a very high value of $\beta$.  Let's take a closer look
#+BEGIN_SRC R :session gbm :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  library(tidyverse)
  library(fgem)
  ogbm_cv_df <- qs::qread("data/cv_elasticnet_models/GBM.qs")
  ## filter(ogbm_cv_df,lambda>0,l1n>1) %>%
  ##   ggplot(aes(x=lambda,y=cv_lik)) +
  ##   geom_point() +
  ##   facet_wrap(~cv_i, scales = "free_y") +
  ##   scale_x_log10()
  gbm_cv_df <- fgem:::summarise_cv_lik(ogbm_cv_df)
  cancer <- "GBM"
  ocancer_df <- qs::qread("data/cleanest_driverMAPS_results_20TumorTypes.qs")  %>% filter(cancer=={{cancer}})
  all_genes <- unique(ocancer_df$Gene)
  go_df <- qs::qread("data/GO_df.qs")
  long_df <- go_df
  blong_df <- bind_rows(
    long_df,
    tibble(Gene=all_genes,feature_name="Intercept"))
    GO_def <- readRDS("data/GO_Definitions.RDS") %>%
      select(feature_name,description=Term)


    all_def <- bind_rows(mutate(GO_def,category="GO",sub_category="BP")
                         )
  xGO <- fgem:::df2sparse(long_df,total_rownames=all_genes)
  xGO <- xGO[ocancer_df$Gene,]
  ym <- ocancer_df$BF

  nX <- nrow(xGO)
#+END_SRC

#+RESULTS:
: 20038

#+BEGIN_SRC R :session gbm :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 

  grad_relaxf <- function(Bdf,l2){
    bf <- Bdf$feature_name[Bdf$feature_name!="Intercept"]
    ix <- xGO[,bf]
    pr <- l2*length(ym)

    progressr::with_progress({
      cv_rfit <- cv_fgem(ix,ym,log_BF=TRUE,stratify_BF=FALSE,alpha=0)
    })


    rrfitt <- fgem:::fgem_elasticnet(ix,ym,log_BF=TRUE,alpha=0,lambda=0,verbose=TRUE)
    rfs <- fgem:::summarise_cv_lik(cv_rfit)

    tgr <- fgem:::fgem_grad.dgCMatrix(rrfitt$Beta,ix,ym,prec=0,log_BF=TRUE)
    gr <- fgem:::fgem_grad.dgCMatrix(Bdf$Beta,ix,ym,prec=l2*nX,log_BF=TRUE)
    mutate(Bdf,grad=gr)
  }

  tight_Beta <- filter(gbm_cv_df,cv_sum==max(cv_sum)) %>% unnest(Beta) %>% filter(Beta!=0) %>% arrange(desc(abs(Beta)))

 
    ## fisher_df <- qs::qread("data/cleanest_single_fisher_cutoffs.qs") %>%
    ##     dplyr::select(cancer,
    ##                   feature_name,
    ##                   pval = p.value,cutoff) %>%
    ##   mutate(cutoff=paste0("pval_fisher_",stringr::str_replace(cutoff,"\\.","_")))%>% spread(key="cutoff",value="pval")

med_BF <- apply(xGO,2,function(x){
  median(eym[x==1])
})
mean_BF <- apply(xGO,2,function(x){
  mean(eym[x==1])
})
min_BF <- apply(xGO,2,function(x){
  min(eym[x==1])
})

max_BF <- apply(xGO,2,function(x){
  max(eym[x==1])
})

perc_p <- apply(xGO,2,function(x){
  mean(ym[x==1]>0)
})



med_lBF <- apply(xGO,2,function(x){
  median(ym[x==1])
})
mean_lBF <- apply(xGO,2,function(x){
  mean(ym[x==1])
})


mean_plBF <- apply(xGO,2,function(x){
  ty <- ym[x==1]
  mean(ty[ty>0])
})
mean_nlBF <- apply(xGO,2,function(x){
  ty <- ym[x==1]
  mean(ty[ty<0])
})


mean_pBF <- apply(xGO,2,function(x){
  ty <- eym[x==1]
  mean(ty[ty>1])
})
mean_nBF <- apply(xGO,2,function(x){
  ty <- eym[x==1]
  mean(ty[ty<1])
})



min_lBF <- apply(xGO,2,function(x){
  min(ym[x==1])
})

max_lBF <- apply(xGO,2,function(x){
  max(ym[x==1])
})


x_df <- tibble(feature_name=names(med_BF),
               med_BF,
               mean_BF,
               min_BF,
               max_BF,
               med_lBF,
               mean_lBF,
               min_lBF,
               max_lBF,
               perc_p,
               mean_plBF,
               mean_nlBF,
               mean_pBF,
               mean_nBF,
               sum_X=apply(xGO,2,sum)
               ) %>% inner_join(select(fgem_results, feature_name, estimate_fgem, Intercept, pval_fgem, qval_fgem, lik), by = "feature_name") %>%
  arrange(desc(estimate_fgem))


#+END_SRC

#+BEGIN_SRC R :session gbm :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 



  fgem_results <- qs::qread("data/alt_new_fgem_marginal_results.qs") %>%
    mutate(trait = map_chr(Beta, ~.x$feature_name[2])) %>%
    unnest(Beta) %>% 
    mutate(feature_name = dplyr::if_else(feature_name == "Intercept", "Intercept", "estimate_fgem")) %>%
    spread(key = "feature_name", value = "Beta") %>%
    rename(feature_name=trait, pval_fgem = pval, qval_fgem = qval) %>%
    filter(cancer=="GBM")

   bad_feat <- filter(fgem_results,estimate_fgem>10) %>% pull(feature_name)
   tX <- as.matrix(xGO[ocancer_df$Gene,bad_feat,drop=FALSE])

  tpfun <- function(B,x,b){
    xb <- b[1] +  x%*%b[-1]
    exp
    B + (1 - B)/(1 + exp()
  }


  marr <- fgem:::fgem_marginal(tX,ym,log_BF=TRUE,max_iter=150,grad=TRUE,hess=TRUE)

  marr_h <- map(marr$Beta,~.x$hessian)
  dets <- map_dbl(marr_h,det)

  mardf <- marr %>%
    mutate(trait = map_chr(Beta, ~.x$feature_name[2])) %>%
    mutate(det= map_dbl(Beta,~det(.x$hessian))) %>% 
    unnest(Beta) %>% select(-hessian) %>% 
    mutate(feature_name = dplyr::if_else(feature_name == "Intercept", "Intercept", "fgem")) %>%
    pivot_wider(names_from = "feature_name", values_from = c("Beta","gradient")) %>%
    rename(feature_name=trait) %>%
    select(feature_name,lik,Beta=Beta_fgem,Intercept=Beta_Intercept,grad_fgem=gradient_fgem,grad_int=gradient_Intercept,time,pval,sum_X,l2n,sum_X,det) %>% arrange(feature_name)

   univr <- unnest(rrfitt,Beta)
   tpI <- rnorm(3500,mean=univr$Beta[1],sd=0)
   tpB <- rnorm(3500,mean=univr$Beta[2],sd=1)

   eym <- exp(ym)
   lik <- map2_dbl(tpI,tpB,function(x,y){
     fgem:::fgem_lik_stan(c(x,y),tX,exp(ym),log_BF=FALSE)
   })
   prior_mat <- mapply(function(x,y){
     stats::plogis(c(y*tX)+x)
   },tpI,tpB)

   lik_mat <- apply(prior_mat,2,function(x){
     log(x*eym+(1-x))
   })

   rownames(lik_mat) <- rownames(tX)
   names(eym) <- rownames(tX)
   lik_df <- as_tibble(lik_mat,rownames="Gene") %>%
     gather(key="Beta",value="Lik",-Gene) %>%
     mutate(Beta=tpB[as.integer(stringr::str_remove(Beta,"V"))],
            )
   lik_df <- mutate(lik_df,BF=eym[Gene])
   lik_df <- mutate(lik_df,has_feat=tX[Gene,1]==1)
   hc <- topo.colors(20, alpha = 1, rev = FALSE)
   hl_df <- filter(lik_df,has_feat)  %>% group_by(Gene) %>% mutate(grad=(Lik-lead(Lik))/(Beta-lead(Beta))) %>% ungroup() %>%
     mutate(BF_bin=hc[as.integer(cut_interval(log10(BF), n=20))])
            grad_bin=hc[as.integer(cut_number(grad, n=20))])
   with(hl_df,plot3d(Beta,log10(BF),lik,col=grad_bin))

   feat_df <- distinct(lik_df,Gene,BF,has_feat)
   group_by(lik_df,has_feat,Beta) %>% summarise(Lik=sum(Lik)) %>% ggplot(aes(x=Beta,y=Lik,col=has_feat))+geom_point()+facet_wrap(~has_feat,scales="free_y")+ggtitle("Likelihood with varying Beta","With or without feature")
   filter(lik_df,has_feat)  %>%
     mutate(pos_BF=BF>1) %>%
     group_by(Beta) %>%
     summarise(mean_lik=mean(Lik),min_lik=min(Lik),max_lik=max(Lik)) %>%
     ggplot(aes(x=Beta,y=mean_lik))+geom_point()
   +geom_ribbon(aes(x=Beta,ymin=min_lik,ymax=max_lik,col=pos_BF,fill=pos_BF),alpha=0.2) +
     ggtitle(paste0("Per-Gene Likelihood for ",tf," Genes"),"Stratified by whether BF>1")
   ggsave("~/tmp/per_gene.png")
   diff_mat <- (cbind(lik_mat[,-1],0)-lik_mat)[,-ncol(lik_mat)]
   diff_mat_g <- diff_mat[tX==1,]
   diff_mat_neg <- diff_mat_g[wmd[,1],]

   fgrad <- mapply(function(x,y){
     fgem:::fgem_grad_stan(c(x,y),tX,exp(ym),log_BF=FALSE)
   },x=tpI,y=tpB)

   grad_df <- tibble(Beta=tpB,Intercept=tpI,Intercept_grad=fgrad[1,],Beta_grad=fgrad[2,],lik=lik) %>%
     mutate(lik_bin=hc[as.integer(cut_number(lik, n=20))],
            beta_grad_bin=hc[as.integer(cut_interval(Beta_grad, n=20))])
   ## #mutate(grad_df, Beta_bin=cut_number(Beta, n=20)) %>%  ggplot(aes(x=Beta_bin,y=lik,group=Beta_bin))+geom_violin()
   ## #ggplot(grad_df,aes(x=Intercept,y=lik))+geom_point()

   ## of <- optim(par=runif(2),gr=fgem:::fgem_grad_stan,fgem:::fgem_lik_stan,X=tX,BF=exp(ym),log_BF=FALSE,prec=0,neg=TRUE)
   ## theta=0 
   ## phi=20
   ## ggplot(grad_df,aes(x=Beta,y=Intercept,z=lik))+theme_void()+axes_3D(theta=theta, phi=phi) +
   ##   stat_3D(theta=theta, phi=phi)
   grad_df <- arrange(grad_df,Beta)
   tgrad_df <- filter(grad_df,Beta<20)
   with(tgrad_df,plot3d(Beta,Intercept,lik,col=beta_grad_bin))

   ggplot(tgrad_df,aes(x=Beta,y=lik,col=Beta_grad))+scale_color_gradient2(trans="log")+geom_point()+ggtitle("Beta vs Likelihood for GO:0050911","Colored by gradient wrt Beta")+ylab("Marginalized Log-Likelihood")
   ggsave(filename="~/tmp/llk.png")
   tr <- mutate(gbm_cv_df,Beta=purrr::map2(Beta,group_l2,grad_f))

#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session gbm :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 



  g
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session gbm :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  with_progress({
    cv_df <- dplyr::mutate(cv_fgem(X,ym,alpha=0.8,stratify_BF=TRUE),cancer=cancer)
  })
  filter(cv_df,lambda>0,l1n>1) %>%
    ggplot(aes(x=lambda,y=cv_lik)) +
    geom_point() +
    facet_wrap(~cv_i,scales="free_y") +
    scale_x_log10()


  scv_df <- fgem:::summarise_cv_lik(cv_df)
  with_progress({
    ccv_df <- dplyr::mutate(cv_fgem(X,ym,alpha=0.8,stratify_BF=FALSE),cancer=cancer)
  })

  with_progress({
    lcv_df <- dplyr::mutate(cv_fgem(X,log(ym),alpha=0.8,stratify_BF=FALSE,log_BF=TRUE),cancer=cancer)
  })
  slcv_df <- fgem:::summarise_cv_lik(lcv_df)
  filter(ccv_df,lambda>0,l1n>1) %>%
    ggplot(aes(x=lambda,y=cv_lik)) +
    geom_point() +
    facet_wrap(~cv_i,scales="free_y") +
    scale_x_log10()

  sccv_df <- fgem:::summarise_cv_lik(ccv_df)
  sccv_df <- inner_join(mutate(sccv_df,ia=NA),
                        filter(sccv_df,cv_sum==max(cv_sum)) %>% transmute(ia=NA,best_group_l1=group_l1,best_group_l2=group_l2,best_cv=cv_sum)) %>% select(-ia)

  filter(sccv_df,group_l1>0) %>%
    ggplot(aes(x=group_l1, y=cv_sum, col=cv_sum==max(cv_sum)))+geom_point()+scale_x_log10()+geom_vline(aes(xintercept=best_group_l1))

  best_gbm <- filter(sccv_df,cv_sum==max(cv_sum))

  qs::qsave(cv_df, op)



#+END_SRC



** IntOGen validation

An alternative source of validation is cite: cite:gonzalez-perez13_intog_mutat_ident_cancer_driver

#+BEGIN_SRC R :session fg :tangle ../scripts/fg.R :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 

  comp_df <- read_tsv("data/2020-02-02_IntOGen-Drivers-20200213/Compendium_Cancer_Genes.tsv")
  cohort_df <- read_tsv("data/2020-02-02_IntOGen-Cohorts-20200213/cohorts.tsv")

  cohort_notcga <- filter(cohort_df,SOURCE!="TCGA") %>% rename(cohort=COHORT)

  sub_comp_df <- select(comp_df,Gene=SYMBOL,cohort=COHORT,cancer=CANCER_TYPE,qval_cons=QVALUE_COMBINATION) %>%
    semi_join(cohort_notcga)

  tcomp_df <- select(comp_df,Gene=SYMBOL,cohort=COHORT,cancer=CANCER_TYPE,qval_cons=QVALUE_COMBINATION) %>%
    semi_join(cohort_notcga) %>% 
    distinct(cancer,Gene) %>%
    mutate(value=1L)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  sub_comp_l <- nest(sub_comp_df,valid_data=c(Gene,qval_cons))
  all_results <- map_df(fs::dir_ls(out_d),function(x){
    N <- length(qs::qread(fs::path("data/y_models",fs::path_file(x))))
    idf <- qs::qread(x) %>% group_by(l1) %>% filter(abs(l1-(lambda*N)*alpha)==min(abs(l1-(lambda*N)*alpha))) %>% ungroup() %>% 
mutate(max_c=map_dbl(Beta,~max(.x$Beta[-1])))
    })


  pred_fun <- function(df,x,y,log=TRUE){
    tibble::tibble(Gene=rownames(x),post=fgem:::gen_u(Beta = df$Beta, x = x[, df$feature_name[-1],drop=FALSE], B = y, log = log))
  }
  cancer <- "BRCA"
  ardf <- filter(all_results,convergence==0) %>% nest(tresults=-cancer)
  log_pbinom <- function(lp,x){
    mean((x*lp)+(1-x)*log(-expm1(lp)))
  }
  post_fun <- function(tresults,cancer){
    ym <- qs::qread(fs::path("data/y_models", cancer, ext = "qs"))
    xm <- qs::qread(fs::path("data/x_models", cancer, ext = "qs"))
    Id <- matrix(0,nrow(xm),0,dimnames=list(rownames(xm),character()))
    intr <- fgem_bfgs(Id,ym)
    trdf <- pred_fun(intr$Beta[[1]],
                     x = Id,
                     y = ym,
                     log=TRUE) %>%
      rename(uniform_post = post)
    tresults <- filter(tresults) %>%
      mutate(pred=map(Beta,pred_fun,x=xm,y=ym))
    unnest(tresults,pred) %>%
      select(functional_post=post,lambda,Gene) %>%
      inner_join(trdf,by="Gene") %>%
      left_join(filter(tcomp_df,cancer=={{cancer}}),by=c("Gene")) %>%
      replace_na(list(value=0L,cancer=cancer))
  }


  post_results <- pmap_dfr(ardf,post_fun) 


  cv_results <- post_results %>% group_by(lambda,cancer) %>%
      summarise(lik_func=log_pbinom(functional_post,value),
                lik_unif=log_pbinom(uniform_post,value)) %>% ungroup() %>%
    inner_join(all_results)

#+END_SRC

#+RESULTS:



I've identified several cancer types where the FGEM model does a better job of predicting known cancer
genes (using the IntOGen database) than the baseline ~driverMAPS~ model.  


#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  library(ggrepel)
  library(patchwork)
  sup_mod <- filter(cv_results, l0n>1) %>%
    filter(lik_func > lik_unif) %>%
    group_by(cancer) %>%
    filter(lik_func==max(lik_func)) %>%
    ungroup()

  any_cg <- group_by(post_results,cancer) %>%
    summarise(has_cg=any(value==1)) %>% filter(has_cg)

  cvb <- semi_join(cv_results,any_cg) %>%
    group_by(lambda) %>%
    summarise(p_best=mean(lik_func>lik_unif,na.rm=TRUE),
              n_best=sum(lik_func>lik_unif,na.rm=TRUE),
              n=n()) %>%
    arrange(desc(n_best),desc(p_best))

  any_best <- semi_join(cv_results,any_cg) %>%group_by(cancer) %>%
    summarise(any_best=any(lik_func>lik_unif,na.rm=T)) %>% filter(any_best)
    group_by(lambda)


  bcvb <- filter(cvb, n_best == max(n_best,na.rm=TRUE),
                 ) %>% filter(lambda==min(lambda))

  cbd <- semi_join(cv_results,any_best) %>% group_by(cancer) %>% filter(lik_func==max(lik_func,na.rm=T)) %>% filter(l0n>1) %>% ungroup() 
  bcvbv <- bcvb$lambda

  cvr <- semi_join(cv_results,any_cg) %>% filter(lambda>0) %>% nest(res=-cancer)

  pwalk(cvr, function(res, cancer){
  plt_a <- res %>% ggplot(aes(x=lambda,y=l0n)) + geom_point(aes(col=lik_func>lik_unif))+geom_vline(xintercept=bcvbv)+ theme(legend.position ="none")+ylab("L0 Norm")
  plt_b <- res %>% ggplot(aes(x=lambda,y=l1n)) + geom_point(aes(col=lik_func>lik_unif))+geom_vline(xintercept=bcvbv)+ theme(legend.position ="none")+ylab("L1 Norm")
  plt_c <- res %>% ggplot(aes(x=lambda,y=l2n)) + geom_point(aes(col=lik_func>lik_unif))+geom_vline(xintercept=bcvbv)+ theme(legend.position = "none")+ylab("L2 Norm")
  plt_d <- res %>% ggplot(aes(x=lambda,y=max_c)) + geom_point(aes(col=lik_func>lik_unif))+geom_vline(xintercept=bcvbv)+ theme(legend.position = "none")+ylab(bquote(max(bgroup("|",beta,"|"))))

  plt <- ((plt_a+plt_b)/(plt_c +plt_d)& stat_smooth(geom='line',alpha=0.2) & xlab(bquote(lambda))) + plot_layout(guides = "collect")+plot_annotation(title=cancer)
  od <- fs::path("org/fgem_elastic_fits")
  fs::dir_create(od)
  ggsave(plt,filename=fs::path(od,cancer,ext="png"))
  })

  plt_a <-semi_join(cv_results,any_cg)  %>%
    filter(lambda>0) %>%
    ggplot(aes(x=lambda,y=l0n)) + geom_point(aes(col=lik_func>lik_unif))+geom_vline(xintercept=bcvbv)+ theme(legend.position ="none")+ylab("L0 Norm")
  plt_b <-semi_join(cv_results,any_cg)  %>%
    filter(lambda>0) %>%
    ggplot(aes(x=lambda,y=l1n)) + geom_point(aes(col=lik_func>lik_unif))+geom_vline(xintercept=bcvbv)+ theme(legend.position ="none")+ylab("L1 Norm")
  plt_c <-semi_join(cv_results,any_cg)  %>%
    filter(lambda>0) %>%
    ggplot(aes(x=lambda,y=l2n)) + geom_point(aes(col=lik_func>lik_unif))+geom_vline(xintercept=bcvbv)+ theme(legend.position = "none")+ylab("L2 Norm")
  plt_d <-semi_join(cv_results,any_cg)  %>%
    filter(lambda>0) %>%
    ggplot(aes(x=lambda,y=max_c)) + geom_point(aes(col=lik_func>lik_unif))+geom_vline(xintercept=bcvbv)+ theme(legend.position = "none")+ylab(bquote(max(bgroup("|",beta,"|"))))
  ((plt_a+plt_b)/(plt_c +plt_d) & stat_smooth(geom='line',alpha=0.2)) &xlab(bquote(lambda)) & facet_wrap(~cancer,scales="free_y")

  sup_post <- post_results %>%
    semi_join(any_cg) %>%
    mutate(isIntoGen = (value == 1))


  plot_post <- inner_join(post_results,cbd) %>%
    mutate(isIntoGen = (value == 1))
  iig <- filter(plot_post, isIntoGen)
  plot_post %>% 
    ggplot(aes(x=exp(uniform_post),y=exp(functional_post),col=isIntoGen))+
    geom_point() +
   geom_text_repel(
     data = iig,
     aes(label=Gene)) + 
    facet_wrap(~cancer) + 
    geom_abline(slope = 1)+
    xlab("Uniform Posterior")+ylab("Functional Posterior")

  GO_def <- readRDS("data/GO_Definitions.RDS") %>% select(feature_name,Term)
  GO_def <- bind_rows(GO_def,tibble(feature_name="Intercept",Term="")) %>% distinct()

  best_res <- unnest(cbd,Beta) %>%
    inner_join(GO_def)  %>%
    mutate(label=paste0(feature_name,":\n",Term)) %>% nest(Beta=c("Beta","feature_name","label","Term"))

  pp <- inner_join(post_results,best_res) %>%
    mutate(is_IntoGen = (value == 1)) %>% 
    nest(post=c("Gene","uniform_post","functional_post","value","is_IntoGen"))

  line_break <- function(x){
    stringr::str_replace_all(x,"([^,]+),([^,]+),([^,]+),","\\1,\\2,\\3,\n")
  }
  
  pp %>% pwalk(function(cancer,Beta,post,...){
    iig <- filter(post, is_IntoGen)
    post_diff <- mutate(post,pd=exp(functional_post)-exp(uniform_post)) %>% arrange(pd)
    top_diff <- bind_rows(slice(post_diff,(n()-2):n()),slice(post_diff,1:3))
  
    nBPGOdf <- bind_rows(select(BPGOdf,feature_name=feature,Gene),tibble(Gene=top_diff$Gene,feature_name="Intercept"))
    BP_assignment <- inner_join(top_diff,nBPGOdf) %>% semi_join(Beta) %>% nest(features=feature_name) %>% mutate(feature_list=map_chr(features,~paste0(.x$feature_name[.x$feature_name!="Intercept"],collapse=","))) %>%
      transmute(Gene=Gene,
                uniform_post=exp(uniform_post),
                functional_post=exp(functional_post),
                isIntoGen=is_IntoGen,
                GO_features=line_break(feature_list))
  
  
    post_plot <- post %>% 
      ggplot(aes(x=exp(uniform_post),y=exp(functional_post),col=is_IntoGen))+
      geom_point() +
      geom_text_repel(
        data = iig,
        aes(label=Gene),col="blue") + 
      geom_abline(slope = 1)+
      xlab("Uniform Posterior")+
      ylab("Functional Posterior")
    coeff_plot <- filter(Beta,Beta!=0) %>% ggplot(aes(x=Beta,y=label))+geom_point()+geom_vline(xintercept=0)
    plt <- (coeff_plot+post_plot+plot_layout(guides = "collect")+plot_annotation(title=cancer))
    od <- fs::path("org/fgem_post_plot")
    fs::dir_create(od)
    ggsave(plt, filename=fs::path(od, cancer, ext="png"),width=11,height=11/(1920/1080))
  })
#+END_SRC


#+BEGIN_SRC R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :colnames yes
    log_pbinom <- function(lp,x){
        mean((x*lp)+(1-x)*log(-expm1(lp)))
      }

    prior_post_plot <- function(data,cancer,valid_data,cohort,...){
      log<-TRUE
      cancer_list <- valid_data$Gene
      ym <- qs::qread(fs::path("data/y_models/",cancer,ext="qs"))
      xm <- qs::qread(fs::path("data/x_models/",cancer,ext="qs"))
      stopifnot(all(data$feature_name %in% colnames(xm)))
      x <- xm[,data$feature_name,drop=FALSE]
      unifp <- fgem:::gen_u(fgem:::fgem_null(ym),x[,"Intercept",drop=FALSE],ym,log=log)
                                            #unifp <- fgem:::prior_mean(BF,log=log)
      cancer_vec <- rownames(x) %in% cancer_list
      fp <- fgem:::gen_u(data$Beta,x,ym,log=log)
      tibble(cancer=cancer, cross_entropy_functional = -log_pbinom(fp,cancer_vec),
             cross_entropy_uniform = -log_pbinom(unifp,cancer_vec),
             cross_entropy_ratio=cross_entropy_functional-cross_entropy_uniform,
             cohort=cohort)
    }

  validation_df <- pmap_dfr(all_rc,prior_post_plot)
#+END_SRC


#+BEGIN_SRC R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :colnames yes
  log_pbinom <- function(lp,x){
    mean((x*lp)+(1-x)*log(-expm1(lp)))
  }

   prior_post_plot <- function(data,cancer,valid_data,...){
     log<-TRUE
     cancer_list <- unique(valid_data$Gene)
     ym <- qs::qread(fs::path("data/y_models/",cancer,ext="qs"))
     xm <- qs::qread(fs::path("data/x_models/",cancer,ext="qs"))
     stopifnot(all(data$feature_name %in% colnames(xm)))
     x <- xm[,data$feature_name,drop=FALSE]
   
     unifp <- fgem:::gen_u(fgem:::fgem_null(ym),x[,"Intercept",drop=FALSE],ym,log=log)
   
   
     fp <- fgem:::gen_u(data$Beta,x,ym,log=log)
     cancer_vec <- rownames(x) %in% cancer_list
   
     tibble(cancer=cancer,
            cross_entropy_functional = log_pbinom(fp,cancer_vec),
            mean_true_functional=mean(exp(fp)[cancer_vec]),
            mean_false_functional=mean(exp(fp)[!cancer_vec]),
            mean_true_uniform=mean(exp(unifp)[cancer_vec]),
            mean_false_uniform=mean(exp(unifp)[!cancer_vec]),
            cross_entropy_uniform = log_pbinom(unifp,cancer_vec),
            cross_entropy_ratio=cross_entropy_functional-cross_entropy_uniform)
   }



  sub_comp_df <- select(comp_df,Gene=SYMBOL,cohort=COHORT,cancer=CANCER_TYPE,qval_cons=QVALUE_COMBINATION) %>% semi_join(cohort_notcga)

  sub_comp_l <- nest(sub_comp_df,valid_data=c(Gene,qval_cons,cohort))
  all_results <- map_df(fs::dir_ls(out_d),qs::qread) %>%
          select(data,pval,qval,cancer)
  all_rc <- inner_join(all_results,sub_comp_l)

  cv_df <- pmap_df(all_rc,prior_post_plot)
#+END_SRC



** TODO Code [66%]
*** DONE Write Vignette
*** DONE Write R package
*** TODO Submit to CRAN (or Bioconductor)
    DEADLINE: <2020-05-16 Sat>


    
    
* Extras

** Trying GLM family function

#+BEGIN_SRC R


logexp <- function(days = 1)
{
    linkfun <- function(mu) qlogis(mu^(1/days))
    linkinv <- function(eta) plogis(eta)^days
    mu.eta  <- function(eta) days * plogis(eta)^(days-1) *
                  binomial()$mu.eta(eta)
    valideta <- function(eta) TRUE
    link <- paste0("logexp(", days, ")")
    structure(list(linkfun = linkfun, linkinv = linkinv,
                   mu.eta = mu.eta, valideta = valideta, name = link),
              class = "link-glm")
}
(bil3 <- binomial(logexp(3)))


#+END_SRC

** FGEM analyses

*** Run FGEM on new set of genes (ASD)
From cite:satterstrom
The Bayes Factors reported in this paper are not suitable for my method.
#+RESULTS:

** Cancer and ExAC 

To start out with we'll use the exac allele z scores and the Biological Process GO terms.
  To reduce multiple testing burden, 
I'll limit the GO terms to terms with 10 or more genes with that term

#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/

z_df <- filter(exacdf,
                 stringr::str_detect(feature, "z$")) %>%
      spread(feature, value) %>%
      select(-class) %>%
      inner_join(min_cancer_df)
  tres_z <- group_by(z_df, cancer) %>%
    do(FGEM_marginal(select(., -cancer),
                     verbose = FALSE)) %>%
    ungroup()
#+END_SRC

#+RESULTS:



* Trying Stan


#+BEGIN_SRC stan :file simple_logistic_model.stan
  data {
    int<lower=1> G;  // number of data points
    int<lower=0> F;  // number of clusters
    vector[G] B;  // Bayes Factors
    matrix[G,F] A; //Annotation Matrix
  }
  parameters {
    vector[F] Beta; // Effect sizes
    real Beta0; //intercept
  }
  /* transformed parameters { */
  /* vector<lower=0,upper=1>[G] pvec=inv_logit(A * Beta + Beta0); */
  /* } */
  model {
    // likelihood
    Beta0 ~ normal(0,5);
    Beta ~ normal(0,4.5);
    for(n in 1:G){
      real pv=Beta0;
      for(k in 1:F){
        pv+=A[n,k]*Beta[k];
      }
      target+=log( inv_logit(pv) * B[n] + (1 - inv_logit(pv)));
    }
  }

#+END_SRC

#+RESULTS:
[[file:simple_logistic_model.stan]]


#+BEGIN_SRC stan :file logistic_model.stan
  data {
    int<lower=1> g;  // number of data points
    int<lower=0> n;  // number of clusters
    vector[g] B;  // Bayes Factors
    matrix[g,n] A; //Annotation Matrix
  }
  parameters {
    vector[n] Beta; // Effect sizes
    real Beta0; //intercept
  }
  /* transformed parameters { */
  /* vector<lower=0,upper=1>[G] pvec=inv_logit(A * Beta + Beta0); */
  /* } */
  model {
    // likelihood
    vector[g] pvec = inv_logit((A*Beta)+Beta0);
    Beta0 ~ normal(-1,4);
    Beta ~ normal(0,4);
    target+=sum(log( pvec .* B + (1 - pvec)));
  }
#+END_SRC

#+RESULTS:
[[file:logistic_model.stan]]

#+BEGIN_SRC stan :file sparse_logistic_model.stan
  data {
    int<lower=1> g;  // number of genes
    int<lower=0> n;  // number of features
    int<lower=0> nnz; //number of non-zero entries in the feature matrix
    vector[g] B;  // Bayes Factors
    vector[nnz] w; //non-zero entries in the feature matrix
    int v[nnz];//column indices
    int u[g+1];//row start indices
  }
  parameters {
    vector[n] Beta; // Effect sizes
    real Beta0; //intercept
  }
  /* transformed parameters { */
  /* vector<lower=0,upper=1>[G] pvec=inv_logit(A * Beta + Beta0); */
  /* } */
  model {
    // likelihood
    vector[g] pvec = inv_logit(csr_matrix_times_vector(g,n,w,v,u,Beta)+Beta0);
    Beta0 ~ normal(-1,4);
    Beta ~ normal(0,4);
    target+=sum(log( pvec .* B + (1 - pvec)));
  }
#+END_SRC

#+RESULTS:
[[file:sparse_logistic_model.stan]]

*** The horseshoe prior

Scale is a combination of scale for each component as well as a global scale  cite:pmlr-v5-carvalho09a


\begin{align*}
\beta_{m} &\sim \mathcal{N} (0, \tau \cdot \lambda_{m})
\\
\lambda_{m} &\sim \text{Half-}\mathcal{C} (0, 1)
\\
\tau &\sim \text{Half-}\mathcal{C} (0, \tau_{0}).
\end{align*}


** The Finnish Horseshoe 

There has been a recent improvement to the horseshoe known as the regularized horseshoe (or informally, the "Finnish Horseshoe")
Using cite:piironen17_spars_infor_regul_horses_other_shrin_prior

$$
\begin{align*}
\beta_{m} &\sim \mathcal{N} (0, \tau \cdot \tilde{\lambda}_{m})
\\
\tilde{\lambda}_{m} &=
\frac{c \lambda_{m}}
{\sqrt{ c^{2} + \tau^{2} \lambda_{m}^{2}}}
\\
\lambda_{m} &\sim \text{Half-}\mathcal{C} (0, 1)
\\
c^{2} &\sim \text{Inv-}\mathcal{G} \, (\frac{\nu}{2}, \frac{\nu}{2} s^{2})
\\
\tau &\sim \text{Half-}\mathcal{C} (0, \tau_{0}).
\end{align*}
$$



#+BEGIN_SRC stan :file sparse_finnish_horseshoe_logistic_model.stan
    data {
      int<lower=1> g;  // number of genes
      int<lower=0> n;  // number of features
      int<lower=0> nnz; //number of non-zero entries in the feature matrix
      real m0 ;           // Expected number of large slopes
      vector[g] B;  // Bayes Factors
      vector[nnz] w; //non-zero entries in the feature matrix
      int v[nnz];//column indices
      int u[g+1];//row start indices

    }
    transformed data {
      real slab_scale = 3;    // Scale for large slopes
      real slab_scale2 = square(slab_scale);
      real slab_df = 25;      // Effective degrees of freedom for large slopes
      real half_slab_df = 0.5 * slab_df;
    }
    parameters {
      vector[n] beta_tilde; // Effect sizes
      real Beta0; //intercept
      vector<lower=0>[n] lambda;
      real<lower=0> c2_tilde;
      real<lower=0> tau_tilde;
      real<lower=0> sigma;
    }
  transformed parameters{
    vector[n] beta;
    {
      real tau0 = (m0 / (n - m0)) * (sigma / sqrt(1.0 * g));
      real tau = tau0 * tau_tilde; // tau ~ cauchy(0, tau0)
  
      // c2 ~ inv_gamma(half_slab_df, half_slab_df * slab_scale2)
      // Implies that marginally beta ~ student_t(slab_df, 0, slab_scale)
      real c2 = slab_scale2 * c2_tilde;
  
      vector[n] lambda_tilde = sqrt( c2 * square(lambda) ./ (c2 + square(tau) * square(lambda)) );
  
      // beta ~ normal(0, tau * lambda_tilde)
      beta = tau * lambda_tilde .* beta_tilde;

    }

  }
    model {

      // likelihood
      vector[g] pvec = inv_logit(csr_matrix_times_vector(g,n,w,v,u,beta)+Beta0);
      beta_tilde ~ normal(0, 1);
      Beta0 ~ normal(-1,2);
      lambda ~ cauchy(0, 1);
      tau_tilde ~ cauchy(0, 1);
      c2_tilde ~ inv_gamma(half_slab_df, half_slab_df);
      target+=sum(log( pvec .* B + (1 - pvec)));
    }

#+END_SRC


#+RESULTS:
[[file:sparse_finnish_horseshoe_logistic_model.stan]]


#+begin_src R :session stan :result silent :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
  options(mc.cores = parallel::detectCores())
    library(rstan)
    library(tidyverse)
    library(fgem)



    data("BPGOdf")
    cancer_df <- qs::qread("data/driverMAPS_results_20TumorTypes/GBM.qs")
    go_df <- select(BPGOdf,Gene,feature) %>% mutate(Gene=as.character(Gene)) %>% filter(Gene %in% cancer_df$Gene)



  genelist_go <- nest(go_df,
                      gene_l = Gene) %>%
    mutate(gene_l = map(gene_l, "Gene"))

  bg_go <- filter(genelist_go,lengths(gene_l)>=15) %>%
    sample_n(100,replace=FALSE) %>% unnest(gene_l)

  big_stan_data_sparse <- tidybayes::compose_data(g = nrow(cancer_df),
                                              n = length(unique(bg_go$feature)),
                                              nnz = nrow(bg_go),
                                              B = cancer_df$BF,
                                              m0=10,
                                              !!!(fgem::trip2sparseMatrix(
                                                          as.character(bg_go$gene_l),
                                                          bg_go$feature,
                                                          total_rownames = cancer_df$Gene,
                                                          add_intercept = FALSE,
                                                          csr = TRUE)))



    golist <- c("GO:0008625","GO:0000003")
  xdf <- filter(genelist_go, feature %in% golist) %>%
    unnest(gene_l)

  stan_data <- tidybayes::compose_data(g = nrow(cancer_df),
                                       n = length(unique(xdf$feature)),
                                       B = cancer_df$BF,
                                       A=fgem::trip2sparseMatrix(
                                               as.character(xdf$gene_l),
                                               xdf$feature,
                                               total_rownames = cancer_df$Gene,
                                               add_intercept = FALSE,
                                               csr = FALSE))

  stan_data_sparse <- tidybayes::compose_data(g = nrow(cancer_df),
                                              n = length(unique(xdf$feature)),
                                              nnz = nrow(xdf),
                                              B = cancer_df$BF,
                                              !!!(fgem::trip2sparseMatrix(
                                                          as.character(xdf$gene_l),
                                                          xdf$feature,
                                                          total_rownames = cancer_df$Gene,
                                                          add_intercept = FALSE,
                                                          csr = TRUE)))
                                     #+end_src
                                     
#+begin_src R :session stan :result silent :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
    options(mc.cores = parallel::detectCores())
      library(rstan)
      library(tidyverse)
      library(fgem)

  cancerf <- fs::path_ext_remove(fs::path_file(fs::dir_ls("../data/fdr_models/")))
  go_df <- select(BPGOdf,Gene,feature) %>% mutate(Gene=as.character(Gene)) 



  genelist_go <- nest(go_df,
                        gene_l = Gene) %>%
      mutate(gene_l = map(gene_l, "Gene"))

    bg_go <- filter(genelist_go,lengths(gene_l)>=15) %>%
      sample_n(100,replace=FALSE) %>% unnest(gene_l)
  for(cancer_t in cancerf){
    cancer_df <- qs::qread(glue::glue("../data/driverMAPS_results_20TumorTypes/{cancer_t}.qs"))
    x <- fgem::trip2sparseMatrix(
                                                            as.character(bg_go$gene_l),
                                                            bg_go$feature,
                                                            total_rownames = cancer_df$Gene,
                                                            add_intercept = FALSE,
                 csr = FALSE)
    if(NCOL(x)>10){
    xl <- extract_sparse_parts(x)
  big_stan_data_sparse <- tidybayes::compose_data(g = nrow(x),
                                                  n = NCOL(x),
                                                  nnz = length(xl$w),
                                                  B = cancer_df$BF,
                                                  m0=10,
                                                  !!!xl
                                                )


  nhsf <- stan(file="sparse_finnish_horseshoe_logistic_model.stan",
               data=big_stan_data_sparse,
              chains=4,iter=1000,
              pars=c("beta","Beta0","lp__"),
              control=list(adapt_delta=0.99, max_treedepth=15),cores=9)
    saveRDS(nhsf,fs::path("../data/fhs/",cancer_t,ext="RDS"))
    }
  }


  #  Elapsed Time: 14.8989 seconds (Warm-up)
  #Chain 1:                12.5116 seconds (Sampling)
  #Chain 1:                27.4105 seconds (Total)

  dlfit <- stan(file="org/logistic_model.stan",
               model_name=cancer_t,
               data=stan_data,
               chains=1,iter=2000)






#+END_SRC 



#+begin_src R :session stan :result silent :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
    xl <- qs::qread("~/tmp/x_mats.qs")
    yl <- qs::qread("~/tmp/yl.qs")
    rstan_options(auto_write = TRUE)

    x <- xl[[1]]
    y <- yl[[1]]
    walk(names(xl),
         function(cancer_t){
      out_f <- fs::path("data/stan_fits",cancer_t,ext="RDS")
      if(!fs::file_exists(out_f)){
        x <- xl[[cancer_t]]
        y <- yl[[cancer_t]]
        G <- nrow(x)
        F <- ncol(x)
      
        saveRDS(lfit,out_f)
      }
    })
#+end_src

#+RESULTS:



# ** Optimizing FGEM

# #+BEGIN_SRC c++
#   #include <iostream>
#   #include <algorithm>
#   #include <cmath>
#   #include <math.h>
#   #include <vector>
#   #include <numeric>

#   using namespace std;

#   //Global Control Variable
#   struct SquaremControl{
#       int K=1;
#       int method=3;//1,2,3 indicates the types of step length to be used in squarem1,squarem2, 4,5 for "rre" and "mpe" in cyclem1 and cyclem2,  standing for reduced-rank ("rre") or minimal-polynomial ("mpe") extrapolation.
#       // K=1 must go with method=1,2 or 3
#       // K>1 must go with method=4 or 5
#       double mstep=4;
#       int maxiter=1500;
#       bool square=true;
#       bool trace=true;//currently set to be true for debugging purpose
#       double stepmin0=1;
#       double stepmax0=1;
#       double kr=1;
#       double objfninc=1;//0 to enforce monotonicity, Inf for non-monotonic scheme, 1 for monotonicity far from solution and allows for non-monotonicity closer to solution
#       double tol=1e-7;
#   } SquaremDefault;

#   //Output Struct
#   struct SquaremOutput{
#       std::vector<double> par;
#       double valueobjfn;
#       int iter=0;
#       int pfevals=0;
#       int objfevals=0;
#       bool convergence=false;
#   } sqobj,sqobjnull;

#   vector<double> fixptfn(std::vector<double> par);
#   double objfn(std::vector<double> par);
#   SquaremOutput squarem1(std::vector<double> par);

#   //Wrapper function
#   SquaremOutput cxxSQUAREM(std::vector<double> par)
#   {
#       if(SquaremDefault.K == 1){
#           sqobj=squarem1(par);
#       }
#       else{
#           sqobj=sqobjnull;
#       }
#       return sqobj;
#   }

#   //actual acceleration function
#   SquaremOutput squarem1(std::vector<double> par){
#       //std::vector<double> p,p1,p2;//R data types
#       double loldcpp,lnewcpp;
#       std::vector<double> pcpp,p1cpp,p2cpp,pnew;
#       std::vector<double> q1,q2,sr2,sq2,sv2,srv;
#       double sr2_scalar,sq2_scalar,sv2_scalar,srv_scalar,alpha,stepmin,stepmax;
#       int iter,feval,leval;
#       bool conv,extrap;
#       stepmin=SquaremDefault.stepmin0;
#       stepmax=SquaremDefault.stepmax0;
#       if(SquaremDefault.trace){std::cout<<"Squarem-1"<<std::endl;}
    
#       iter=1;pcpp=par;pnew=par;
#       try{loldcpp=objfn(pcpp);leval=1;}
#       catch(...){
#           std::cout<<"Error in fixptfn function evaluation";
#           return sqobjnull;
#       }
#       lnewcpp=loldcpp;
#       if(SquaremDefault.trace){std::cout<<"Objective fn: "<<loldcpp<<std::endl;}
#       feval=0;conv=true;
    
#       const long int parvectorlength=pcpp.size();
    
#       while(feval<SquaremDefault.maxiter){
#           //Step 1
#           extrap = true;
#           try{p1cpp=fixptfn(pcpp);feval++;}
#           catch(...){
#               std::cout<<"Error in fixptfn function evaluation";
#               return sqobjnull;
#           }
        
#           sr2_scalar=0;
#           for (int i=0;i<parvectorlength;i++){sr2_scalar+=pow(p1cpp[i]-pcpp[i],2);}
#           if(sqrt(sr2_scalar)<SquaremDefault.tol){break;}
        
#           //Step 2
#           try{p2cpp=fixptfn(p1cpp);feval++;}
#           catch(...){
#               std::cout<<"Error in fixptfn function evaluation";
#               return sqobjnull;
#           }
#           sq2_scalar=0;
#           for (int i=0;i<parvectorlength;i++){sq2_scalar+=pow(p2cpp[i]-p1cpp[i],2);}
#           //sq2_scalar=sqrt(sq2_scalar);
#           if (sqrt(sq2_scalar)<SquaremDefault.tol){break;}
#           sv2_scalar=0;
#           for (int i=0;i<parvectorlength;i++){sv2_scalar+=pow(p2cpp[i]-2*p1cpp[i]+pcpp[i],2);}
#           srv_scalar=0;
#           for (int i=0;i<parvectorlength;i++){srv_scalar+=(p2cpp[i]-2*p1cpp[i]+pcpp[i])*(p1cpp[i]-pcpp[i]);}
#           //std::cout<<"sr2,sv2,srv="<<sr2_scalar<<","<<sv2_scalar<<","<<srv_scalar<<std::endl;//debugging
        
#           //Step 3 Proposing new value
#           switch (SquaremDefault.method){
#               case 1: alpha= -srv_scalar/sv2_scalar;
#               case 2: alpha= -sr2_scalar/srv_scalar;
#               case 3: alpha= sqrt(sr2_scalar/sv2_scalar);
#           }
        
#           alpha=std::max(stepmin,std::min(stepmax,alpha));
#           //std::cout<<"alpha="<<alpha<<std::endl;//debugging
#           for (int i=0;i<parvectorlength;i++){pnew[i]=pcpp[i]+2.0*alpha*(p1cpp[i]-pcpp[i])+pow(alpha,2)*(p2cpp[i]-2*p1cpp[i]+pcpp[i]);}
#           //pnew = pcpp + 2.0*alpha*q1 + alpha*alpha*(q2-q1);
        
#           //Step 4 stabilization
#           if(std::abs(alpha-1)>0.01){
#               try{pnew=fixptfn(pnew);feval++;}
#               catch(...){
#                   pnew=p2cpp;
#                   try{lnewcpp=objfn(pnew);leval++;}
#                   catch(...){
#                       lnewcpp=loldcpp;
#                   }
#                   if(alpha==stepmax){
#                       stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
#                   }
#                   alpha=1;
#                   extrap=false;
#                   if(alpha==stepmax){stepmax=SquaremDefault.mstep*stepmax;}
#                   if(stepmin<0 && alpha==stepmin){stepmin=SquaremDefault.mstep*stepmin;}
#                   pcpp=pnew;
#                   if(!std::isnan(lnewcpp)){loldcpp=lnewcpp;}
#                   if(SquaremDefault.trace){std::cout<<"Objective fn: "<<lnewcpp<<"  Extrapolation: "<<extrap<<"  Steplength: "<<alpha<<std::endl;}
#                   iter++;
#                   continue;//next round in while loop
#               }
            
#               if (isfinite(SquaremDefault.objfninc)){
#                   try{lnewcpp=objfn(pnew);leval++;}
#                   catch(...){
#                       pnew=p2cpp;
#                       try{lnewcpp=objfn(pnew);leval++;}
#                       catch(...){
#                           std::cout<<"Error in objfn function evaluation";
#                           return sqobjnull;
#                       }
#                       if(alpha==stepmax){
#                           stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
#                       }
#                       alpha=1;
#                       extrap=false;
#                   }
#               }else{lnewcpp=loldcpp;}
#               if (lnewcpp>loldcpp+SquaremDefault.objfninc) {
#                   pnew=p2cpp;
#                   try{lnewcpp=objfn(pnew);leval++;}
#                   catch(...){
#                       std::cout<<"Error in objfn function evaluation";
#                       return sqobjnull;
#                   }
#                   if(alpha==stepmax){
#                       stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
#                   }
#                   alpha=1;
#                   extrap=false;
#               }
#           }else{//same as above, when stablization is not performed.
#               if (isfinite(SquaremDefault.objfninc)){
#                   try{lnewcpp=objfn(pnew);leval++;}
#                   catch(...){
#                       pnew=p2cpp;
#                       try{lnewcpp=objfn(pnew);leval++;}
#                       catch(...){
#                           std::cout<<"Error in objfn function evaluation";
#                           return sqobjnull;
#                       }
#                       if(alpha==stepmax){
#                           stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
#                       }
#                       alpha=1;
#                       extrap=false;
#                   }
#               }else{lnewcpp=loldcpp;}
#               if (lnewcpp>loldcpp+SquaremDefault.objfninc) {
#                   pnew=p2cpp;
#                   try{lnewcpp=objfn(pnew);leval++;}
#                   catch(...){
#                       std::cout<<"Error in objfn function evaluation";
#                       return sqobjnull;
#                   }
#                   if(alpha==stepmax){
#                       stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
#                   }
#                   alpha=1;
#                   extrap=false;
#               }
#           }
#           if(alpha==stepmax){stepmax=SquaremDefault.mstep*stepmax;}
#           if(stepmin<0 && alpha==stepmin){stepmin=SquaremDefault.mstep*stepmin;}
        
#           pcpp=pnew;
#           if(!std::isnan(lnewcpp)){loldcpp=lnewcpp;}
#           if(SquaremDefault.trace){std::cout<<"Objective fn: "<<lnewcpp<<"  Extrapolation: "<<extrap<<"  Steplength: "<<alpha<<std::endl;}
#           iter++;
#           //std::cout<<"leval="<<leval<<std::endl;//debugging
#       }
    
#       if (feval >= SquaremDefault.maxiter){conv=false;}
#       if (!isfinite(SquaremDefault.objfninc)){loldcpp=objfn(pcpp);leval++;}
    
#       //assigning values
#       sqobj.par=pcpp;
#       sqobj.valueobjfn=loldcpp;
#       sqobj.iter=iter;
#       sqobj.pfevals=feval;
#       sqobj.objfevals=leval;
#       sqobj.convergence=conv;
#       return(sqobj);
#   }


#   SquaremOutput squarem2(std::vector<double> par){
#       double res,parnorm,kres;
#       std::vector<double> pcpp,p1cpp,p2cpp,pnew,ptmp;
#       std::vector<double> q1,q2,sr2,sq2,sv2,srv;
#       double sr2_scalar,sq2_scalar,sv2_scalar,srv_scalar,alpha,stepmin,stepmax;
#       int iter,feval;
#       bool conv,extrap;
#       stepmin=SquaremDefault.stepmin0;
#       stepmax=SquaremDefault.stepmax0;
#       if(SquaremDefault.trace){std::cout<<"Squarem-1"<<std::endl;}
    
#       iter=1;pcpp=par;pnew=par;
#       feval=0;conv=true;
    
#       const long int parvectorlength=pcpp.size();
    
#       while(feval<SquaremDefault.maxiter){
#           //Step 1
#           extrap = true;
#           try{p1cpp=fixptfn(pcpp);feval++;}
#           catch(...){
#               std::cout<<"Error in fixptfn function evaluation";
#               return sqobjnull;
#           }
        
#           sr2_scalar=0;
#           for (int i=0;i<parvectorlength;i++){sr2_scalar+=pow(p1cpp[i]-pcpp[i],2);}
#           if(sqrt(sr2_scalar)<SquaremDefault.tol){break;}
        
#           //Step 2
#           try{p2cpp=fixptfn(p1cpp);feval++;}
#           catch(...){
#               std::cout<<"Error in fixptfn function evaluation";
#               return sqobjnull;
#           }
#           sq2_scalar=0;
#           for (int i=0;i<parvectorlength;i++){sq2_scalar+=pow(p2cpp[i]-p1cpp[i],2);}
#           sq2_scalar=sqrt(sq2_scalar);
#           if (sq2_scalar<SquaremDefault.tol){break;}
#           res=sq2_scalar;
        
#           sv2_scalar=0;
#           for (int i=0;i<parvectorlength;i++){sv2_scalar+=pow(p2cpp[i]-2*p1cpp[i]+pcpp[i],2);}
#           srv_scalar=0;
#           for (int i=0;i<parvectorlength;i++){srv_scalar+=(p2cpp[i]-2*p1cpp[i]+pcpp[i])*(p1cpp[i]-pcpp[i]);}
#           //std::cout<<"sr2,sv2,srv="<<sr2_scalar<<","<<sv2_scalar<<","<<srv_scalar<<std::endl;//debugging
        
#           //Step 3 Proposing new value
#           switch (SquaremDefault.method){
#               case 1: alpha= -srv_scalar/sv2_scalar;
#               case 2: alpha= -sr2_scalar/srv_scalar;
#               case 3: alpha= sqrt(sr2_scalar/sv2_scalar);
#           }
        
#           alpha=std::max(stepmin,std::min(stepmax,alpha));
#           //std::cout<<"alpha="<<alpha<<std::endl;//debugging
#           for (int i=0;i<parvectorlength;i++){pnew[i]=pcpp[i]+2.0*alpha*(p1cpp[i]-pcpp[i])+pow(alpha,2)*(p2cpp[i]-2*p1cpp[i]+pcpp[i]);}
#           //pnew = pcpp + 2.0*alpha*q1 + alpha*alpha*(q2-q1);
        
#           //Step 4 stabilization
#           if(std::abs(alpha-1)>0.01){
#               try{ptmp=fixptfn(pnew);feval++;}
#               catch(...){
#                   pnew=p2cpp;
#                   if(alpha==stepmax){
#                       stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
#                   }
#                   alpha=1;
#                   extrap=false;
#                   if(alpha==stepmax){stepmax=SquaremDefault.mstep*stepmax;}
#                   if(stepmin<0 && alpha==stepmin){stepmin=SquaremDefault.mstep*stepmin;}
#                   pcpp=pnew;
#                   if(SquaremDefault.trace){std::cout<<"Residual: "<<res<<"  Extrapolation: "<<extrap<<"  Steplength: "<<alpha<<std::endl;}
#                   iter++;
#                   continue;//next round in while loop
#               }
#               res=0;
#               for (int i=0;i<parvectorlength;i++){res+=pow(ptmp[i]-pnew[i],2);}
#               res=sqrt(res);
#               parnorm=0;
#               for (int i=0;i<parvectorlength;i++){parnorm+=pow(p2cpp[i],2);}
#               parnorm=sqrt(parnorm/parvectorlength);
#               kres=SquaremDefault.kr*(1+parnorm)+sq2_scalar;
#               if(res <= kres){
#                   pnew=ptmp;
#               }else{
#                   pnew=p2cpp;
#                   if(alpha==stepmax){stepmax=SquaremDefault.mstep*stepmax;}
#                   alpha=1;
#                   extrap=false;
#               }
#           }
        
#           if(alpha==stepmax){stepmax=SquaremDefault.mstep*stepmax;}
#           if(stepmin<0 && alpha==stepmin){stepmin=SquaremDefault.mstep*stepmin;}
        
#           pcpp=pnew;
#           if(SquaremDefault.trace){std::cout<<"Residual: "<<res<<"  Extrapolation: "<<extrap<<"  Steplength: "<<alpha<<std::endl;}
#           iter++;
#       }
    
#       if (feval >= SquaremDefault.maxiter){conv=false;}
    
#       //assigning values
#       sqobj.par=pcpp;
#       sqobj.valueobjfn=NAN;
#       sqobj.iter=iter;
#       sqobj.pfevals=feval;
#       sqobj.objfevals=0;
#       sqobj.convergence=conv;
#       return(sqobj);
#   }

#   SquaremOutput fpiter(std::vector<double> par){
#       //std::vector<double> p,p1,p2;//R data types
#       double lnewcpp,res;
#       std::vector<double> pcpp,pnew;
#       int iter;
#       bool conv;
#       if(SquaremDefault.trace){std::cout<<"Standaard Fixed Point Iteration:"<<std::endl;}
#       iter=1;res=NAN;conv=false;
#       pcpp=par;
#       const long int parvectorlength=pcpp.size();
#       while(iter<SquaremDefault.maxiter*4){
#           pnew=fixptfn(pcpp);
#           res=0;
#           for (int i=0;i<parvectorlength;i++){res+=pow(pnew[i]-pcpp[i],2);}
#           res=sqrt(res);
#           if(res<SquaremDefault.tol){conv=true;break;}
#           if(SquaremDefault.trace){
#               if(fmod(iter,100)==0){
#                   std::cout<<"Iter: "<<iter<<"Residual: "<<res<<std::endl;
#               }
#           }
#           pcpp=pnew;
#           iter++;
#       }
    
#       lnewcpp=objfn(pcpp);
#       //assigning values
#       sqobj.par=pcpp;
#       sqobj.valueobjfn=lnewcpp;
#       sqobj.iter=iter;
#       sqobj.pfevals=iter;
#       sqobj.objfevals=1;
#       sqobj.convergence=conv;
#       return(sqobj);
#   }


#   //main() used for demostration

#   std::vector<int> Other_input1 {162,267,271,185,111,61,27,8,3,1};

#   int main(){
#       std::cout<<"Hi, this is a demostration using Poisson mixture!"<<std::endl;
#       std::vector<double> par_initial {0.5,3,1};//some random starting point,
#       SquaremOutput SQ_result;
    
#       std::cout<<"\n\n\nDemo1: using squarem1 and the objective function"<<endl;
#       SQ_result=squarem1(par_initial);
#       cout<<"Initial input vector:"<<endl;
#       for(int i=0;i<par_initial.size();i++) cout<<par_initial[i]<<" ";
#       cout<<"\nOutput vector by SQUAREM:"<<endl;
#       for(int i=0;i<par_initial.size();i++) cout<<SQ_result.par[i]<<" ";
#       cout<<"\nNumber of evaluations on fixed point function:"<<endl;
#       cout<<SQ_result.pfevals<<endl;
#       cout<<"Number of evaluations on objective function:"<<endl;
#       cout<<SQ_result.objfevals<<endl;
    
#       std::cout<<"\n\n\nDemo2: using squarem2 without objective function"<<endl;
#       SQ_result=squarem2(par_initial);
#       cout<<"Initial input vector:"<<endl;
#       for(int i=0;i<par_initial.size();i++) cout<<par_initial[i]<<" ";
#       cout<<"\nOutput vector by SQUAREM:"<<endl;
#       for(int i=0;i<par_initial.size();i++) cout<<SQ_result.par[i]<<" ";
#       cout<<"\nNumber of evaluations on fixed point function:"<<endl;
#       cout<<SQ_result.pfevals<<endl;
#       cout<<"Number of evaluations on objective function:"<<endl;
#       cout<<SQ_result.objfevals<<endl;
    
#       std::cout<<"\n\n\nDemo3: using simple fixed point iteration"<<endl;
#       SQ_result=fpiter(par_initial);
#       cout<<"Initial input vector:"<<endl;
#       for(int i=0;i<par_initial.size();i++) cout<<par_initial[i]<<" ";
#       cout<<"\nOutput vector by SQUAREM:"<<endl;
#       for(int i=0;i<par_initial.size();i++) cout<<SQ_result.par[i]<<" ";
#       cout<<"\nNumber of evaluations on fixed point function:"<<endl;
#       cout<<SQ_result.pfevals<<endl;
#       cout<<"Number of evaluations on objective function:"<<endl;
#       cout<<SQ_result.objfevals<<endl;
    
#       return 0;
#   }


#   //Fixed point function and objective function that take only the vector for EM acceleration as input, while others are defined as global variables(const within the scope of cxxSQUAREM)

#   vector<double> fixptfn(std::vector<double> par){
#       std::vector<double> parnew=par;
    
#       std::vector<double> zi(Other_input1.size());
#       for (int i=0;i<Other_input1.size();i++){
#           zi[i]=par[0]*exp(-par[1])*pow(par[1],i)/(par[0]*exp(-par[1])*pow(par[1],i)+(1-par[0])*exp(-par[2])*pow(par[2],i));
#       }
    
    
#       double temp1,temp2;
#       //parnew[0]=1;
#       temp1=0,temp2=0;
#       for (int i=0;i<Other_input1.size();i++){
#           temp1+=Other_input1[i]*zi[i];
#           temp2+=Other_input1[i];
#       }
#       parnew[0]=temp1/temp2;
    
    
#       temp1=0,temp2=0;
#       for (int i=0;i<Other_input1.size();i++){
#           temp1+=Other_input1[i]*zi[i]*i;
#           temp2+=Other_input1[i]*zi[i];
#       }
#       parnew[1]=temp1/temp2;
    
#       temp1=0,temp2=0;
#       for (int i=0;i<Other_input1.size();i++){
#           temp1+=Other_input1[i]*(1-zi[i])*i;
#           temp2+=Other_input1[i]*(1-zi[i]);
#       }
#       parnew[2]=temp1/temp2;
    
#       return parnew;
#   }


#   double objfn(std::vector<double> par){
#       double objvalue=0;
#       vector<double> loglik(Other_input1.size());
#       for (int i=0;i<Other_input1.size();i++){
#           loglik[i]=Other_input1[i]*log(par[0]*exp(-par[1])*pow(par[1],i)/exp(lgamma(i+1))+
#                                         (1-par[0])*exp(-par[2])*pow(par[2],i)/exp(lgamma(i+1)));
#           objvalue-=loglik[i];
#       }
#       return objvalue;
#   };

# #+END_SRC




# ** Prognostic signatures

# #+BEGIN_QUOTE
# Based on the FPKM value of each gene, 
# patients were classified into two expression groups 
# and the correlation between expression level and 
# patient survival was examined. 
# The prognosis of each group of patients was examined by Kaplan-Meier 
# survival estimators, and the survival outcomes of the two groups were 
# compared by log-rank tests. Both median and maximally separated 
# Kaplan-Meier plots are presented in the Human Protein Atlas, and genes 
# with log rank P values less than 0.001 in maximally separated Kaplan-Meier 
# analysis were defined as prognostic genes. If the group of patients with 
# high expression of a selected prognostic gene has a higher observed event than 
# expected event, it is an unfavourable prognostic gene; otherwise, it is a 
# favourable prognostic gene. Genes with a median expression less than FPKM 1 
# were lowly expressed, and classified as unprognostic in the database even if 
# they exhibited significant prognostic effect in survival analysis
# #+END_QUOTE


# #+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :colnames yes
#   library(dplyr)
#   library(purrr)
#   library(fgem)
#   library(readr)
#   library(ggplot2)
#   library(tidyr)
# #+END_SRC


# #+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
# prior_post_plot <- function(name=NULL,log=FALSE,use_null=TRUE){
#       tcancer_df <- qs::qread(glue::glue("data/driverMAPS_results_20TumorTypes/{name}.qs"))
#       Genes <- tcancer_df$Gene
#       BF <- tcancer_df$BF
#       fit <- qs::qread(glue::glue("data/models/{name}.qs"))
#       tbm <- unnest(fit,data) %>% pull(feature_name)
#       go_df <- dplyr::filter(BPGOdf, feature %in% tbm)
#       x <- fgem::trip2sparseMatrix(as.character(go_df$Gene),
#                                    go_df$feature,
#                                    go_df$value,
#                                    Genes,
#                                    unique(go_df$feature),
#                                    add_intercept = TRUE)
#       if(use_null){
#         unifp <- fgem:::gen_u(fgem:::fgem_null(BF),x[,"Intercept",drop=FALSE],BF,log=log)
#       }else{
#         unifp <- fgem:::prior_mean(BF,log=log)
#       }
#       tibble::tibble(Gene=Genes,
#                      functional_posterior = predict_fgem(fit, x, BF, log=log),
#                      uniform_posterior = unifp)
#   }
# #+END_SRC

# #+RESULTS:

# #+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
# cancer_map <-tibble::tribble(
#                          ~cancer,~cancer_name,
#                          "GBM","glioma",
#                          "BRCA","breast cancer",
#                          "PRAD","prostate cancer",
#                          "UCEC", "endometrial cancer",
#                          "CESC", "cervical cancer",
#                          "BLCA", "urotherial cancer",
#                          "LUAD", "lung cancer",
#                          "HNSC", "head and neck cancer",
#                          "KIRP", "renal cancer",
#                          "UCS", NA,
#                          "KIRC", "KIRC",
#                          "SARC", NA,
#                          "SKCM", "melanoma",
#                          "LUSC", "lung cancer",
#                          "PAAD", "pancreatic cancer",
#                          "TGCT", "testis cancer",
#                          "ESCA", NA,
#                          "LIHC", "liver cancer")


# posterior_df <- select(cancer_map,cancer) %>% 
# mutate(data=map(cancer,prior_post_plot,log=TRUE)) %>% 
# unnest(data)

# #+END_SRC

# #+RESULTS:

# #+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  

#   sfit_df <- unnest(fit,data) %>%
#   select(feature=feature_name,Beta)
#   sub_BPGO_df <- go_df %>%
#   inner_join(nGO_def,by="feature") %>%
#   select(-class) %>% 
#   mutate(Gene=as.character(Gene))
#       pldf <- left_join(plotdf, sub_BPGO_df,by="Gene") %>%
#         tidyr::replace_na(list(feature="Intercept",
#                                feature_term="None/Other",
#                                Term="",
#                                value=0L)) %>%
#         left_join(sfit_df,by="feature") %>%
#         mutate(feature_term=paste0(feature,"\n",Term,"\n", "Beta: ",format(Beta,digits=3)))

#       lf <- as_labeller(set_names(pldf$feature_term,pldf$feature))

#       ggplot(pldf, aes(x = uniform_posterior, y = functional_posterior, col = feature)) +
#         geom_point() + geom_abline(slope=1)+
#         facet_wrap(~feature,labeller=lf)+ ggtitle(paste0(name,"\nModel pvalue: ",fit$pval))
#     }
# #+END_SRC

# #+RESULTS:


# #+BEGIN_SRC  R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
#   library(ggrepel)
#   library(readr)

#   prog_cols <- cols(
#     ensembl = col_character(),
#     Gene = col_character(),
#     cancer_name = col_character(),
#     High = col_double(),
#     Medium = col_double(),
#     Low = col_double(),
#     Not_detected = col_double(),
#     prognostic_favourable = col_double(),
#     unprognostic_favourable = col_double(),
#     prognostic_unfavourable = col_double(),
#     unprognostic_unfavourable = col_double()
#   )

#   prog_df  <- read_tsv("data/pathology.tsv",skip=1L,col_names=names(prog_cols$cols),col_types=prog_cols) %>%
#       select(-ensembl) %>%
#       distinct() %>%
#       pivot_longer(cols=contains("prognostic")) %>%
#       distinct()  %>% separate(name,into=c("isPrognostic","isFavourable"))


#       all_prog_df <- inner_join(prog_df,cancer_map) %>%
#       select(-cancer_name) %>% group_by(cancer,Gene) %>%
#       summarise(prognostic_p=min(value)) %>%
#       ungroup()

#     ap_df <- distinct(all_prog_df,cancer) %>%
#       mutate(data=map(cancer,prior_post_plot)) %>%
#       unnest(data) %>%
#       left_join(all_prog_df) %>%
#       replace_na(list(prognostic_p=1.0)) %>%
#       mutate(is_prognostic=prognostic_p<0.01) %>%
#       inner_join(model_size) %>%
#       filter(model_terms>10)

#     plot_l <- split(ap_df,ap_df$cancer) %>% map(~ggplot(.x,aes(x=uniform_posterior,y=functional_posterior,label=Gene,col=is_prognostic))+
#                                                   geom_point() +
#                                                   geom_text_repel(
#                                                     data          = filter(.x, is_prognostic)) +
#                                                   geom_abline(slope=1))

#     prog_mod <- gather(ap_df, key = "model", value = "posterior",
#                        functional_posterior,
#                        uniform_posterior) %>%
#       mutate(is_prognostic = prognostic_p<0.05) %>% 
#       group_by(cancer, model) %>% 
#       do(glance(glm(is_prognostic~posterior,
#                     data=.,
#                     family=binomial()))) %>%
#       ungroup()

#     select(prog_mod, cancer, model, logLik) %>%
#       spread(model,logLik) %>%
#       mutate(dev_diff=functional_posterior>uniform_posterior) %>% inner_join(model_size)
# #+END_SRC

# #+RESULTS:

bibliography:references.bib
