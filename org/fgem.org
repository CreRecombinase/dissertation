#+TITLE: Functional Enrichment by Expectation Maximization Project
#+SETUPFILE: setup.org
#+OPTIONS: toc:2

* TODO FGEM Project [0%]
** TODO Write Paper [0%]
   DEADLINE: <2020-05-13 Wed>
+ Target submission to Bioinformatics
*** TODO Introduction 
*** TODO Statistical Method 
*** Application to Cancer
*** TODO Software
*** TODO Results 
*** TODO Discussion
** TODO Analyses [66%]
   DEADLINE: <2020-05-04 Mon>
*** DONE Run FGEM on driverMAPS TCGA

*** DONE use multiple testing correction in forward selection
**** TODO fisher's exact test
***** 1 at a time followed by joint analysis
**** TODO posterior for genes with and without prior
**** TODO Yuwen's annotation data 
**** TODO CancerMAPS Bayes Factors from driverMAPS
***** Get list of genes from siming 
***** What gene sets to use for Siming:
+ screen single feature models and use significant ones in a joint model
*** TODO make plots 
**** Multivariate enrichment
* Analysis
#+BEGIN_SRC R  :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
library(tidyverse)
library(fgem)
library(qs)
#+END_SRC


**** Looking at the data
We'll start by reading the data, pulling out the info we'll use, and saving it back in a nicer format
#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/  :results none
data_f <- fs::dir_ls("data/driverMAPS_results_20TumorTypes",glob="*txt")
cancer_t <- str_replace(data_f, ".+/([A-Z]+)_BayesFactorFDR.txt", "\\1")

vc <- readr::cols(
  Gene = col_character(),
                 No_nonsyn = col_skip(),
                 functypecode8 = col_skip(),
                 mycons = col_skip(),
                 sift = col_skip(),
                 phylop100 = col_skip(),
                 MA = col_skip(),
                 No_unique_mutation = col_skip(),
                 TSG_BF = col_double(),
                 OG_BF = col_double(),
                 Expected_syn = col_skip(),
                 No_syn = col_skip(),
                 BF = col_double(),
                 predtag = col_skip(),
                 Posterior = col_skip(),
                 FDR = col_skip()
  )

    cancer_df <- map2_df(data_f,
                         cancer_t,
                         ~vroom::vroom(.x,
                                       col_names = names(vc$cols),
                                       col_types = vc,
                                       skip = 1L) %>% mutate(cancer = .y))

  saveRDS(cancer_df,"data/driverMAPS_results_20TumorTypes.RDS")
  qs::qsave(cancer_df,"data/driverMAPS_results_20TumorTypes.qs")
#+END_SRC



#+BEGIN_SRC R :colnames yes :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
head(cancer_df)
#+END_SRC

#+RESULTS:
| Gene   |            TSG_BF |             OG_BF |               BF | cancer |
|--------+-------------------+-------------------+------------------+--------|
| PIK3CA | -1.77971729131923 |  322.833185837287 | 322.140038656727 | BLCA   |
| FGFR3  |  28.0895429320585 |  246.567548311336 | 245.874401130776 | BLCA   |
| TP53   |  191.788256479794 |  70.7692247503828 | 191.095109299234 | BLCA   |
| ERBB2  |  2.30809843606858 |  111.697583835288 | 111.004436654728 | BLCA   |
| ERCC2  |  14.6298592310469 |   80.657307268368 | 79.9641600878081 | BLCA   |
| ARID1A |  71.9813145469098 | -11.8163792581274 | 71.2881673663499 | BLCA   |


driverMAPS reports the $\text{BF}$'s as $log(\text{BF})$.  I haven't figured out a way to work with these values without 
exponentiating them and some of them are really big(small).  I'm going to have to "clamp" them between the minimum and maximum representable values
(using double precision floating point).  

**** GO terms

I'm going to pull the GO annotations from the ~GO.db~ package.

#+BEGIN_SRC R :session bioc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :results none
library(tidyverse)
library(fgem)
library(GO.db)
library(qs)
#+END_SRC

#+RESULTS:
| GO.db         |
| fgem          |
| forcats       |
| stringr       |
| dplyr         |
| purrr         |
| readr         |
| tidyr         |
| tibble        |
| ggplot2       |
| tidyverse     |
| org.Hs.eg.db  |
| AnnotationDbi |
| IRanges       |
| S4Vectors     |
| Biobase       |
| BiocGenerics  |
| parallel      |
| stats4        |
| stats         |
| graphics      |
| grDevices     |
| utils         |
| datasets      |
| methods       |
| base          |

#+BEGIN_SRC R :session bioc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :results none
  cancer_df <- qread("data/driverMAPS_results_20TumorTypes.qs")
  tbp <- topGO::annFUN.org("BP",feasibleGenes=unique(cancer_df$Gene),mapping="org.Hs.eg.db",ID="symbol")
  tbp_df <- imap_dfr(tbp,function(Genes,GO)tibble(Gene=Genes,feature_name=GO))
  qs::qsave(tbp_df,"data/GO_df.qs")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session bioc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :results none
  term_list <- as.list(GOTERM)    
  fn_df <- distinct(tbp_df,feature_name) %>% 
    pull(feature_name) %>% map_dfr(function(x){
      tx <- term_list[[x]]
      tibble(feature_name=x,
             Term=Term(tx),
             Definition=Definition(tx),
             Synonyms=list(Synonym(tx)))
    })
  qs::qsave(fn_df,"data/GO_Definitions.qs")
#+END_SRC

**** Fitting univariate models

#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
  library(tidyverse)
  library(fgem)
  library(progressr)
  library(future.apply)
  library(qs)
  library(profvis)

  cancer_df <- qs::qread("data/driverMAPS_results_20TumorTypes.qs")
  BPGOdf <- qs::qread("data/GO_df.qs")
  min_cancer_df <- cancer_df %>%
    select(Gene, BF, cancer) %>%
    mutate(BF = exp(BF))

  go_df <- mutate(BPGOdf,Gene=as.character(Gene)) %>%
    semi_join(distinct(cancer_df,Gene)) %>%
    select(-class)

  go_df <- group_by(go_df,feature) %>%
    summarise(n_gt=n()) %>%
    filter(n_gt>=10) %>%
    select(feature) %>%
    inner_join(go_df)

  cancers <- distinct(cancer_df,cancer)
  tc  <- cancers$cancer[1]
  tcp <- fs::path("data/driverMAPS_results_20TumorTypes",tc,ext="qs")
  cdf <- qread(tcp)
  null_mod <- fgem:::fgem_null(cdf$BF)

  all_mods <- group_by(go_df,feature) %>%
    do(
      fgem(
        x = as.matrix(fgem::trip2sparseMatrix(as.character(.$Gene),
                                            .$feature,
                                            .$value,
                                            cdf$Gene,
                                            unique(.$feature),
                                            add_intercept = TRUE)),
        BF = cdf$BF,
        null_beta = null_mod))


#+END_SRC


**** Analyzing univariate models

#+BEGIN_SRC R :session jacc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  library(dplyr)
  library(purrr)
  library(fgem)
  library(ggplot2)
  library(tidyr)
  bp_name <- readRDS("data/GO_Definitions.RDS") 
  results_df <- readRDS("data/fgem_data.RDS")  %>%
    group_by(cancer) %>%
    filter(convergence==TRUE) %>%
    select(-convergence,-NullLogLik,-Chisq) %>%
    mutate(qval=p.adjust(pval,method="fdr")) %>%
    ungroup() %>%
    arrange(qval) %>%
    rename(feature_name=trait) %>%
    inner_join(bp_name)
  data("BPGOdf")

  sig_features <- group_by(results_df,cancer) %>%
    filter(qval<0.2)  %>%
    ungroup() %>%
    select(cancer,feature=feature_name,qval,data)

  data("BPGOdf")
  go_df <- select(BPGOdf,Gene,feature) %>% 
    mutate(Gene=as.character(Gene))
  genelist_go <- nest(go_df,gene_l=Gene) %>% 
    mutate(gene_l=map(gene_l,"Gene"))  %>%
    inner_join(select(sig_features,feature,cancer))
  cancer_df <- qs::qread("data/driverMAPS_results_20TumorTypes.qs") %>%
    mutate(BF=exp(BF)) %>% select(Gene,BF,cancer)

  cancer_genes <- cancer_df %>% select(Gene,cancer) %>%
    nest(cancer_genes=Gene) %>% mutate(cancer_genes=map(cancer_genes,"Gene"))

  go_list_dfl <- genelist_go %>% 
    inner_join(cancer_genes,by="cancer") %>%
    mutate(gene_l = map2(gene_l, cancer_genes, ~factor(.x[.x %in% .y], levels = .y)),
                         n_genes = lengths(gene_l)) %>%
    select(-cancer_genes)

  x_mats <- split(go_list_dfl,go_list_dfl$cancer) %>% 
  map(function(x){
    tdf <- unnest(x,gene_l)
    as.matrix(trip2sparseMatrix(as.character(tdf$gene_l),tdf$feature,total_rownames=levels(tdf$gene_l)))
  })
  x_mats <- x_mats[order(map_int(x_mats,NCOL))]
  yl <- split(cancer_df$BF,cancer_df$cancer)
  yl <- yl[names(x_mats)]

  ody <- fs::path("data/y_models")
  fs::dir_create(ody)
  odx <- fs::path("data/x_models")
  fs::dir_create(odx)
  iwalk(x_mats,function(x,y){
    qs::qsave(x,fs::path(odx,y,ext="qs"))
  })
  iwalk(yl,function(x,y){
    qs::qsave(x,fs::path(ody,y,ext="qs"))
  })
#+END_SRC

#+RESULTS:



#+BEGIN_SRC R :session fitmult :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
    library(dplyr)
    library(purrr)
    library(fgem)
    library(ggplot2)
    library(tidyr)

    library(progressr)
    library(future.apply)
    plan(multisession)
    out_d <- fs::path("/home/nwknoblauch/Dropbox/Repos/dissertation/data/fdr_models/")
    fs::dir_create(out_d)

    ody <- fs::path("data/y_models")
    odx <- fs::path("data/x_models")
    ct <- fs::path_ext_remove(fs::path_file(fs::dir_ls(odx)))
    cancer_i <- seq_along(ct)

    with_progress({
        p <- progressor(along=cancer_i)
      all_results <- future_lapply(cancer_i,function(a,best_models,odx,ody,out_d){
        p(sprintf("i=%g",a))
        cancer_t <- best_models[a]
        op <- fs::path(out_d,cancer_t,ext="qs")
        if(fs::file_exists(op)){
          return(qs::qread(op))
        }
        x <- qs::qread(fs::path(odx,cancer_t,ext="qs"))
        y <- qs::qread(fs::path(ody,cancer_t,ext="qs"))
        fun_result <- dplyr::mutate(fgem::forward_select_fgem_lik(x,y),cancer=cancer_t)
        qs::qsave(fun_result,op)
        return(fun_result)
      },
      best_models=ct,
      odx=odx,
      ody=ody,
      out_d=out_d,
      future.packages=c("dplyr","purrr","qs","fgem"))
    })
#+END_SRC


**** Plotting multivariate models

#+BEGIN_SRC R :session jacc :dir /home/nwknoblauch/Dropbox/Repos/dissertation/


  GO_def <- readRDS("data/GO_Definitions.RDS") %>% select(feature_name,Term)
  GO_def <- bind_rows(GO_def,tibble(feature_name="Intercept",Term="")) %>% distinct()
  out_d <- fs::path("/home/nwknoblauch/Dropbox/Repos/dissertation/data/fdr_models/")
  all_results_df <- map_df(fs::dir_ls(out_d),qs::qread) %>%
    select(-term)  %>%
    unnest(data)  %>%
    inner_join(GO_def) %>%
    mutate(label=paste0(feature_name,":\n",Term))

  data("BPGOdf")
  head(cancer_df)
  plot_d <- fs::path("/home/nwknoblauch/Dropbox/Repos/dissertation/org/fgem_plots/")
  fs::dir_create(plot_d)
  gen_x <- function(cancer_df,go_df,model_df){
    ig_df <- semi_join(go_df,select(model_df,feature=feature_name),by="feature")
    as.matrix(suppressWarnings(fgem::trip2sparseMatrix(rowname_vals=as.character(ig_df$Gene),
                                      colname_vals=ig_df$feature,
                                      ig_df$value,
                                      total_rownames=cancer_df$Gene,
                                      unique(ig_df$feature),
                                      add_intercept = TRUE)))
  }

  gen_beta <- function(df){
    magrittr::set_names(df$Beta,df$feature_name)
    }



  split(all_results_df,all_results_df$cancer) %>% walk(function(df){
    name <- df$cancer[1]
    tcf <- glue::glue("data/driverMAPS_results_20TumorTypes/{name}.qs")
    if(file.exists(tcf)){
      tcancer_df <- qs::qread(tcf)
      x <- gen_x(tcancer_df,BPGOdf,df)
      cn <- factor(colnames(x))
      beta <- gen_beta(df)[colnames(x)]

      sbpdf <- filter(BPGOdf,feature %in% levels(cn)) %>% mutate(feature=factor(feature,levels=levels(cn)))
      df <- mutate(df,feature_name=factor(feature_name,levels=levels(cn)))
      prior_p <- fgem:::gen_p(beta,x)
      post_p <- fgem::predict_fgem(nest(df,data=c("feature_name","Beta")),x,tcancer_df$BF)

      null_post <- fgem:::gen_u(fgem:::fgem_null(tcancer_df$BF),x[,"Intercept",drop=FALSE],tcancer_df$BF,log=FALSE)
      pa <- rename(df,feature=feature_name) %>% ggplot(aes(x=Beta,y=label))+geom_point(aes(col=feature))+xlab("Beta")+ylab("Feature")+ggtitle(name)+theme(legend.position = "none")
      pb_df <- tibble(uniform_posterior=null_post,
                      functional_posterior=post_p,
                      Gene=tcancer_df$Gene) 
      top_change <- bind_rows(slice(arrange(pb_df,uniform_posterior-functional_posterior),1:4),
                              slice(arrange(pb_df,desc(uniform_posterior-functional_posterior)),1:4))
      pb_df <- pb_df %>% left_join(sbpdf) %>%
        replace_na(list(feature=factor("Intercept",levels=levels(cn))))
      pb <- ggplot(pb_df,aes(x=uniform_posterior,y=functional_posterior,label=Gene))+geom_point(aes(col=feature))+ geom_text_repel(data = top_change,col="red")
      ggsave(filename=fs::path(plot_d,name,ext="png"),plot=pa+pb+plot_layout(guides = "collect"),dpi=300)
    }
  })

#+END_SRC


** COSMIC census

From [[https://cancer.sanger.ac.uk/census][Cosmic:]]
#+BEGIN_QUOTE
The Cancer Gene Census (CGC) is an ongoing effort to catalogue those genes which contain mutations that have been causally implicated in cancer and explain how dysfunction of these genes drives cancer. The content, the structure, and the curation process of the Cancer Gene Census was described and published in Nature Reviews Cancer.

The census is not static, instead it is updated when new evidence comes to light. In particular we are grateful to Felix Mitelman and his colleagues in providing information on more genes involved in uncommon translocations in leukaemias and lymphomas. Currently, more than 1% of all human genes are implicated via mutation in cancer. Of these, approximately 90% contain somatic mutations in cancer, 20% bear germline mutations that predispose an individual to cancer and 10% show both somatic and germline mutations.
Census tiers

Genes in the Cancer Gene Census are divided into two groups, or tiers.
Tier 1

To be classified into Tier 1, a gene must possess a documented activity relevant to cancer, along with evidence of mutations in cancer which change the activity of the gene product in a way that promotes oncogenic transformation. We also consider the existence of somatic mutation patterns across cancer samples gathered in COSMIC. For instance, tumour suppressor genes often show a broad range of inactivating mutations and dominant oncogenes usually demonstrate well defined hotspots of missense mutations. Genes involved in oncogenic fusions are included in Tier 1 when changes to their function caused by the fusion drives oncogenic transformation, or in cases when they provide regulatory elements to their partners (e.g. active promoter or dimerisation domain).
Tier 2

A new section of the Census, which consists of genes with strong indications of a role in cancer but with less extensive available evidence. These are generally more recent targets, where the body of evidence supporting their role is still emerging.
Hallmarks

New overviews of cancer gene function focused on hallmarks of cancer pull together manually curated information on the function of proteins coded by cancer genes and summarise the data in simple graphical form. They present a condensed overview of most relevant facts with quick access to the literature source, and define whether a gene has a stimulating or suppressive effect via individual cancer hallmarks. Genes with the hallmark descriptions available are marked with the hallmark icon, that when clicked, opens the hallmark page. Hallmark descriptions will be expanded to encompass more genes and updated on regular basis. 

#+END_QUOTE

#+BEGIN_SRC R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :colnames yes
  library(broom)
  ccols <- cols(
    Gene = col_character(),
    Name = col_skip(),
    `Entrez GeneId` = col_skip(),
    `Genome Location` = col_skip(),
    Tier = col_integer(),
    Hallmark = col_character(),
    `Chr Band` = col_skip(),
    Somatic = col_factor(levels="yes"),
    Germline = col_factor(levels="yes"),
    SomaticTypes = col_character(),
    GermlineTypes = col_character(),
    `Cancer Syndrome` = col_skip(),
    `Tissue Type` = col_skip(),
    `Molecular Genetics` = col_skip(),
    `Role in Cancer` = col_skip(),
    `Mutation Types` = col_skip(),
    `Translocation Partner` = col_skip(),
    `Other Germline Mut` = col_skip(),
    `Other Syndrome` = col_skip(),
    Synonyms = col_skip()
  )
  cancer_census <- readr::read_csv("data/cancer_gene_census.csv",col_names=names(ccols$cols),col_types=ccols,skip=1L) %>% 
  mutate(is_census=TRUE)


  ## xl <- qs::qread("~/tmp/x_mats.qs")
  ## yl <- qs::qread("~/tmp/yl.qs")

  GO_def <- readRDS("data/GO_Definitions.RDS") %>% select(feature_name,Term)
  GO_def <- bind_rows(GO_def,tibble(feature_name="Intercept",Term="")) %>% distinct()
  out_d <- fs::path("data/fdr_models/")

  all_results <- map_df(fs::dir_ls(out_d),qs::qread) %>%
      select(-term)

  all_results_df <- all_results  %>%
      unnest(data)  %>%
      inner_join(GO_def) %>%
      mutate(label=paste0(feature_name,":\n",Term))




  gen_go_mat <- function(datadl,cancer,cancer_list){
    xm <- qs::qread(fs::path("data/x_models/",cancer,ext="qs"))
    stopifnot(all(datadl$feature_name %in% colnames(xm)))
    x <- xm[,datadl$feature_name,drop=FALSE]
    cancer_vec <- rownames(xm) %in% cancer_list
    odf <- as_tibble(x) %>% mutate(cl=as.integer(cancer_vec))
    broom::tidy(glm(cl~.+0,data=odf,family=binomial())) %>%
      rename(feature_name=term)
  }
    ## apply(x,2,function(y){
    ##   broom::tidy(glm(fisher.test(y,cancer_vec))
    ## }) %>%
    ##   bind_rows() %>%
    ##   mutate(feature_name=colnames(x),cancer=cancer)

logit_df <- map2_dfr(all_results$data,all_results$cancer,gen_go_mat,cancer_list=cancer_census$Gene) %>%
    select(cancer,feature_name,pval_fisher=p.value)

  fisher_df <- map2_dfr(all_results$data,all_results$cancer,gen_go_mat,cancer_list=cancer_census$Gene) %>%
    select(cancer,feature_name,pval_fisher=p.value)
  univ_assoc <- readRDS("data/fgem_data.RDS")  %>% select(cancer,feature_name=trait,pval_logit=pval) %>% 
    inner_join(select(fisher_df,cancer,feature_name,pval_fisher=p.value)) 


  filter(all_results_df,feature_name!="Intercept")


#+END_SRC

#+BEGIN_SRC R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :colnames yes
  log_pbinom <- function(lp,x){
      sum(x*lp+(1-x)*log(expm1(-lp)))
    }

  prior_post_plot <- function(datadl,cancer,log=TRUE,cancer_list){
    ym <- qs::qread(fs::path("data/y_models/",cancer,ext="qs"))
    xm <- qs::qread(fs::path("data/x_models/",cancer,ext="qs"))
    stopifnot(all(datadl$feature_name %in% colnames(xm)))
    x <- xm[,datadl$feature_name,drop=FALSE]
    unifp <- fgem:::gen_u(fgem:::fgem_null(ym),x[,"Intercept",drop=FALSE],ym,log=log)
                                          #unifp <- fgem:::prior_mean(BF,log=log)
    cancer_vec <- rownames(x) %in% cancer_list
    fp <- fgem:::gen_u(datadl$Beta,x,ym,log=log)
    tibble(cancer=cancer, cross_entropy_functional = -log_pbinom(fp,cancer_vec),
           cross_entropy_uniform = -log_pbinom(unifp,cancer_vec),
           cross_entropy_ratio=cross_entropy_functional-cross_entropy_uniform)
  }
#+END_SRC

#+BEGIN_SRC R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :colnames yes
map2_dfr(all_results$data,all_results$cancer,prior_post_plot,cancer_list=cancer_census$Gene)


#+END_SRC

#+BEGIN_SRC R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :colnames yes
library(broom)
  post_df <- gather(posterior_df,
                    key = "model",
                    value = "posterior",
                    functional_posterior,
                    uniform_posterior)
  cosmic_summ_df <-
    left_join(post_df,
              select(cancer_census, Gene, is_census),
              ) %>%
    replace_na(list(is_census=FALSE))

  log_pbinom <- function(lp,x){
    sum(x*lp+(1-x)*log(expm1(-lp)))
  }

  cosmic_summ_df  %>%
    group_by(cancer, model) %>%
    summarise(lik=log_pbinom(posterior, as.integer(is_census))) %>%
    ungroup() %>%
    spread(model, lik) %>%
    mutate(functional_over_uniform = functional_posterior - uniform_posterior)

#+END_SRC


#+BEGIN_SRC R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :results graphics :file pp_BRCA.png
prior_post_plot("BRCA")
#+END_SRC

#+RESULTS:
[[file:/home/nwknoblauch/Dropbox/Repos/dissertation/pp_BRCA.png]]

#+BEGIN_SRC R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
  res_df <- group_by(abp_df, cancer) %>% 
    mutate(qval = p.adjust(pval, method = "fdr")) %>%
    ungroup() %>%
    filter(qval<0.05) %>%
    unnest(data) %>% filter(feature_name!="Intercept") %>% 
    select(cancer,Beta,feature_name,pval,qval) %>%
    inner_join(select(GO_def,feature_name,Term)) %>% 
    inner_join(bpct,by=c("feature_name"="feature"))
  
#+END_SRC


#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
  cancer_results_z <- group_by(z_df,cancer) %>%
    do(FGEM_df(select(.,-cancer)))  %>%
    ungroup()

#+END_SRC



#+RESULTS:
| data/driverMAPS_results_20TumorTypes/BLCA_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/BRCA_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/CESC_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/CHOL_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/ESCA_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/GBM_BayesFactorFDR.txt  |
| data/driverMAPS_results_20TumorTypes/HNSC_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/KICH_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/KIRC_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/KIRP_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/LIHC_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/LUAD_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/LUSC_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/PAAD_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/PRAD_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/SARC_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/SKCM_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/TGCT_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/UCEC_BayesFactorFDR.txt |
| data/driverMAPS_results_20TumorTypes/UCS_BayesFactorFDR.txt  |
|                                                              |

#+BEGIN_SRC shell :dir /home/nwknoblauch/Dropbox/Repos/dissertation/

head data/driverMAPS_results_20TumorTypes/BLCA_BayesFactorFDR.txt
#+END_SRC

#+RESULTS:
| gene   | No_nonsyn | functypecode8 | mycons | sift | phylop100 |  MA | No_unique_mutation |            TSG_BF |             OG_BF |      Expected_syn | No_syn |               BF | predtag | Posterior | FDR |
| PIK3CA |        91 |             1 |     89 |    6 |        87 |  17 |                 38 | -1.77971729131923 |  322.833185837287 |  1.60503435072367 |      3 | 322.140038656727 | OG      |         0 |   0 |
| FGFR3  |        60 |             1 |     41 |   56 |        38 |  46 |                 16 |  28.0895429320585 |  246.567548311336 |  2.58519789350249 |      5 | 245.874401130776 | OG      |         0 |   0 |
| TP53   |       199 |            45 |    117 |  160 |       113 | 140 |                108 |  191.788256479794 |  70.7692247503828 | 0.799997206011002 |      4 | 191.095109299234 | TSG     |         0 |   0 |
| ERBB2  |        46 |             0 |     32 |   31 |        33 |  25 |                 24 |  2.30809843606858 |  111.697583835288 |   3.5070448870326 |     13 | 111.004436654728 | OG      |         0 |   0 |
| ERCC2  |        35 |             0 |     33 |   33 |        34 |  32 |                 21 |  14.6298592310469 |   80.657307268368 |  2.40194445478549 |      3 | 79.9641600878081 | OG      |         0 |   0 |
| ARID1A |        89 |            50 |     56 |   24 |        62 |  24 |                 82 |  71.9813145469098 | -11.8163792581274 |  5.94515709042778 |      8 | 71.2881673663499 | TSG     |         0 |   0 |
| RXRA   |        21 |             2 |     19 |   18 |        17 |  16 |                 10 |   10.330122151452 |  68.6071185191931 |   1.4924320182157 |      4 | 67.9139713386331 | OG      |         0 |   0 |
| RB1    |        55 |            47 |     25 |   15 |        39 |   3 |                 51 |  62.8380702415249 | -18.2860565473209 |  1.25925520375977 |      1 | 62.1449230609649 | TSG     |         0 |   0 |
| RHOB   |        29 |             0 |     28 |   28 |        23 |  14 |                 19 |  21.7741683274798 |   48.854704589876 | 0.830247325203024 |      0 | 48.1615574093178 | OG      |         0 |   0 |




*** TODO Characterize extent of collinearity issue
** TODO Code [66%]
*** DONE Write Vignette
*** DONE Write R package
*** TODO Submit to CRAN (or Bioconductor)
    DEADLINE: <2020-05-16 Sat>




* Extras

** FGEM analyses

*** Run FGEM on new set of genes (ASD)
From cite:satterstrom
The Bayes Factors reported in this paper are not suitable for my method.
#+RESULTS:

** Cancer and ExAC 

To start out with we'll use the exac allele z scores and the Biological Process GO terms.
  To reduce multiple testing burden, 
I'll limit the GO terms to terms with 10 or more genes with that term

#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/

z_df <- filter(exacdf,
                 stringr::str_detect(feature, "z$")) %>%
      spread(feature, value) %>%
      select(-class) %>%
      inner_join(min_cancer_df)
  tres_z <- group_by(z_df, cancer) %>%
    do(FGEM_marginal(select(., -cancer),
                     verbose = FALSE)) %>%
    ungroup()
#+END_SRC

#+RESULTS:



** Trying Stan


#+BEGIN_SRC stan :file simple_logistic_model.stan
  data {
    int<lower=1> G;  // number of data points
    int<lower=0> F;  // number of clusters
    vector[G] B;  // Bayes Factors
    matrix[G,F] A; //Annotation Matrix
  }
  parameters {
    vector[F] Beta; // Effect sizes
    real Beta0; //intercept
  }
  /* transformed parameters { */
  /* vector<lower=0,upper=1>[G] pvec=inv_logit(A * Beta + Beta0); */
  /* } */
  model {
    // likelihood
    Beta0 ~ normal(-3.85,5);
    for
    Beta ~ normal(0,4.5);
    for(n in 1:G){
      real pv=Beta0;
      for(k in 1:F){
        pv+=A[n,k]*Beta[k];
      }
      target+=log( inv_logit(pv) * B[n] + (1 - inv_logit(pv)));
    }
  }

#+END_SRC

#+RESULTS:
[[file:simple_logistic_model.stan]]


#+BEGIN_SRC stan :file logistic_model.stan

  data {
    int<lower=1> G;  // number of data points
    int<lower=0> F;  // number of clusters
    vector[G] B;  // Bayes Factors
    matrix[G,F] A; //Annotation Matrix
  }
  parameters {
    vector[F] Beta; // Effect sizes
    real Beta0; //intercept
  }
  /* transformed parameters { */
  /* vector<lower=0,upper=1>[G] pvec=inv_logit(A * Beta + Beta0); */
  /* } */
  model {
    // likelihood
    vector[G] pvec = inv_logit(A*Beta+Beta0);
    Beta0 ~ normal(-2,5);
    Beta ~ normal(2,5);
    target+=sum(log( pvec .* B + (1 - pvec)));
  }

#+END_SRC


#+BEGIN_SRC stan :file gamma_logistic_model.stan

  data {
    int<lower=1> G;  // number of data points
    int<lower=0> F;  // number of clusters
    vector[G] B;  // Bayes Factors
    matrix[G,F] A; //Annotation Matrix
  }
  parameters {
    vector[F] Beta; // Effect sizes
    real Beta0; //intercept
    real<lower=0> shape;
    real<lower=0> rate;
  }
  /* transformed parameters { */
  /* vector<lower=0,upper=1>[G] pvec=inv_logit(A * Beta + Beta0); */
  /* } */
  model {
    // likelihood
    vector[G] pvec = inv_logit(A*Beta+Beta0);
    Beta0 ~ normal(-2,5);
    Beta ~ gamma(shape,rate);
    target+=sum(log( pvec .* B + (1 - pvec)));
  }

#+END_SRC


#+BEGIN_SRC stan :file finnish_horseshoe_logistic_model.stan
  data {
    int<lower=1> G;  // number of data points
    int<lower=0> F;  // number of clusters
    vector[G] B;  // Bayes Factors
    matrix[G,F] A; //Annotation Matrix
  }
  parameters {
    vector[F] Beta; // Effect sizes
    real Beta0; //intercept
    real<lower=0> shape;
    real<lower=0> rate;
  }
  /* transformed parameters { */
  /* vector<lower=0,upper=1>[G] pvec=inv_logit(A * Beta + Beta0); */
  /* } */
  model {
    // likelihood
    vector[G] pvec = inv_logit(A*Beta+Beta0);
    Beta0 ~ normal(-2,5);
    Beta ~ gamma(shape,rate);
    target+=sum(log( pvec .* B + (1 - pvec)));
  }

#+END_SRC







#+RESULTS:
[[file:gamma_logistic_model.stan]]


#+begin_src R :session stan :result silent :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
options(mc.cores = parallel::detectCores())
  library(rstan)
  library(tidyverse)
  library(fgem)

  data("BPGOdf")
  cancer_df <- qs::qread("data/driverMAPS_results_20TumorTypes/GBM.qs")
  go_df <- select(BPGOdf,Gene,feature) %>% mutate(Gene=as.character(Gene)) %>% filter(Gene %in% cancer_df$Gene)
  
  genelist_go <- nest(go_df,gene_l=Gene) %>% mutate(gene_l=map(gene_l,"Gene"))
  
  golist <- c("GO:0008625")
  xdf <- filter(genelist_go,feature %in% golist) %>% unnest(gene_l)
  x <- as.matrix(fgem::trip2sparseMatrix(as.character(xdf$gene_l),
  xdf$feature,
  total_rownames=cancer_df$Gene,
  add_intercept = FALSE))
  G <- nrow(cancer_df)
  y <- cancer_df$BF
  F <- ncol(x)
#+end_src

#+RESULTS:
: 1

#+begin_src R :session stan :result silent :dir /home/nwknoblauch/Dropbox/Repos/dissertation/
  xl <- qs::qread("~/tmp/x_mats.qs")
  yl <- qs::qread("~/tmp/yl.qs")
  rstan_options(auto_write = TRUE)

  x <- xl[[1]]
  y <- yl[[1]]
  walk(names(xl),
       function(cancer_t){
    out_f <- fs::path("data/stan_fits",cancer_t,ext="RDS")
    if(!fs::file_exists(out_f)){
      x <- xl[[cancer_t]]
      y <- yl[[cancer_t]]
      G <- nrow(x)
      F <- ncol(x)
      lfit <- stan(file="org/gamma_logistic_model.stan",
                   model_name=cancer_t,
                   data=list(G=G, A=x,B=y,F=F),
                   chains=4,iter=2000)
      saveRDS(lfit,out_f)
    }
  })
#+end_src

#+RESULTS:



** Optimizing FGEM

#+BEGIN_SRC c++
  #include <iostream>
  #include <algorithm>
  #include <cmath>
  #include <math.h>
  #include <vector>
  #include <numeric>

  using namespace std;

  //Global Control Variable
  struct SquaremControl{
      int K=1;
      int method=3;//1,2,3 indicates the types of step length to be used in squarem1,squarem2, 4,5 for "rre" and "mpe" in cyclem1 and cyclem2,  standing for reduced-rank ("rre") or minimal-polynomial ("mpe") extrapolation.
      // K=1 must go with method=1,2 or 3
      // K>1 must go with method=4 or 5
      double mstep=4;
      int maxiter=1500;
      bool square=true;
      bool trace=true;//currently set to be true for debugging purpose
      double stepmin0=1;
      double stepmax0=1;
      double kr=1;
      double objfninc=1;//0 to enforce monotonicity, Inf for non-monotonic scheme, 1 for monotonicity far from solution and allows for non-monotonicity closer to solution
      double tol=1e-7;
  } SquaremDefault;

  //Output Struct
  struct SquaremOutput{
      std::vector<double> par;
      double valueobjfn;
      int iter=0;
      int pfevals=0;
      int objfevals=0;
      bool convergence=false;
  } sqobj,sqobjnull;

  vector<double> fixptfn(std::vector<double> par);
  double objfn(std::vector<double> par);
  SquaremOutput squarem1(std::vector<double> par);

  //Wrapper function
  SquaremOutput cxxSQUAREM(std::vector<double> par)
  {
      if(SquaremDefault.K == 1){
          sqobj=squarem1(par);
      }
      else{
          sqobj=sqobjnull;
      }
      return sqobj;
  }

  //actual acceleration function
  SquaremOutput squarem1(std::vector<double> par){
      //std::vector<double> p,p1,p2;//R data types
      double loldcpp,lnewcpp;
      std::vector<double> pcpp,p1cpp,p2cpp,pnew;
      std::vector<double> q1,q2,sr2,sq2,sv2,srv;
      double sr2_scalar,sq2_scalar,sv2_scalar,srv_scalar,alpha,stepmin,stepmax;
      int iter,feval,leval;
      bool conv,extrap;
      stepmin=SquaremDefault.stepmin0;
      stepmax=SquaremDefault.stepmax0;
      if(SquaremDefault.trace){std::cout<<"Squarem-1"<<std::endl;}
    
      iter=1;pcpp=par;pnew=par;
      try{loldcpp=objfn(pcpp);leval=1;}
      catch(...){
          std::cout<<"Error in fixptfn function evaluation";
          return sqobjnull;
      }
      lnewcpp=loldcpp;
      if(SquaremDefault.trace){std::cout<<"Objective fn: "<<loldcpp<<std::endl;}
      feval=0;conv=true;
    
      const long int parvectorlength=pcpp.size();
    
      while(feval<SquaremDefault.maxiter){
          //Step 1
          extrap = true;
          try{p1cpp=fixptfn(pcpp);feval++;}
          catch(...){
              std::cout<<"Error in fixptfn function evaluation";
              return sqobjnull;
          }
        
          sr2_scalar=0;
          for (int i=0;i<parvectorlength;i++){sr2_scalar+=pow(p1cpp[i]-pcpp[i],2);}
          if(sqrt(sr2_scalar)<SquaremDefault.tol){break;}
        
          //Step 2
          try{p2cpp=fixptfn(p1cpp);feval++;}
          catch(...){
              std::cout<<"Error in fixptfn function evaluation";
              return sqobjnull;
          }
          sq2_scalar=0;
          for (int i=0;i<parvectorlength;i++){sq2_scalar+=pow(p2cpp[i]-p1cpp[i],2);}
          //sq2_scalar=sqrt(sq2_scalar);
          if (sqrt(sq2_scalar)<SquaremDefault.tol){break;}
          sv2_scalar=0;
          for (int i=0;i<parvectorlength;i++){sv2_scalar+=pow(p2cpp[i]-2*p1cpp[i]+pcpp[i],2);}
          srv_scalar=0;
          for (int i=0;i<parvectorlength;i++){srv_scalar+=(p2cpp[i]-2*p1cpp[i]+pcpp[i])*(p1cpp[i]-pcpp[i]);}
          //std::cout<<"sr2,sv2,srv="<<sr2_scalar<<","<<sv2_scalar<<","<<srv_scalar<<std::endl;//debugging
        
          //Step 3 Proposing new value
          switch (SquaremDefault.method){
              case 1: alpha= -srv_scalar/sv2_scalar;
              case 2: alpha= -sr2_scalar/srv_scalar;
              case 3: alpha= sqrt(sr2_scalar/sv2_scalar);
          }
        
          alpha=std::max(stepmin,std::min(stepmax,alpha));
          //std::cout<<"alpha="<<alpha<<std::endl;//debugging
          for (int i=0;i<parvectorlength;i++){pnew[i]=pcpp[i]+2.0*alpha*(p1cpp[i]-pcpp[i])+pow(alpha,2)*(p2cpp[i]-2*p1cpp[i]+pcpp[i]);}
          //pnew = pcpp + 2.0*alpha*q1 + alpha*alpha*(q2-q1);
        
          //Step 4 stabilization
          if(std::abs(alpha-1)>0.01){
              try{pnew=fixptfn(pnew);feval++;}
              catch(...){
                  pnew=p2cpp;
                  try{lnewcpp=objfn(pnew);leval++;}
                  catch(...){
                      lnewcpp=loldcpp;
                  }
                  if(alpha==stepmax){
                      stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
                  }
                  alpha=1;
                  extrap=false;
                  if(alpha==stepmax){stepmax=SquaremDefault.mstep*stepmax;}
                  if(stepmin<0 && alpha==stepmin){stepmin=SquaremDefault.mstep*stepmin;}
                  pcpp=pnew;
                  if(!std::isnan(lnewcpp)){loldcpp=lnewcpp;}
                  if(SquaremDefault.trace){std::cout<<"Objective fn: "<<lnewcpp<<"  Extrapolation: "<<extrap<<"  Steplength: "<<alpha<<std::endl;}
                  iter++;
                  continue;//next round in while loop
              }
            
              if (isfinite(SquaremDefault.objfninc)){
                  try{lnewcpp=objfn(pnew);leval++;}
                  catch(...){
                      pnew=p2cpp;
                      try{lnewcpp=objfn(pnew);leval++;}
                      catch(...){
                          std::cout<<"Error in objfn function evaluation";
                          return sqobjnull;
                      }
                      if(alpha==stepmax){
                          stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
                      }
                      alpha=1;
                      extrap=false;
                  }
              }else{lnewcpp=loldcpp;}
              if (lnewcpp>loldcpp+SquaremDefault.objfninc) {
                  pnew=p2cpp;
                  try{lnewcpp=objfn(pnew);leval++;}
                  catch(...){
                      std::cout<<"Error in objfn function evaluation";
                      return sqobjnull;
                  }
                  if(alpha==stepmax){
                      stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
                  }
                  alpha=1;
                  extrap=false;
              }
          }else{//same as above, when stablization is not performed.
              if (isfinite(SquaremDefault.objfninc)){
                  try{lnewcpp=objfn(pnew);leval++;}
                  catch(...){
                      pnew=p2cpp;
                      try{lnewcpp=objfn(pnew);leval++;}
                      catch(...){
                          std::cout<<"Error in objfn function evaluation";
                          return sqobjnull;
                      }
                      if(alpha==stepmax){
                          stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
                      }
                      alpha=1;
                      extrap=false;
                  }
              }else{lnewcpp=loldcpp;}
              if (lnewcpp>loldcpp+SquaremDefault.objfninc) {
                  pnew=p2cpp;
                  try{lnewcpp=objfn(pnew);leval++;}
                  catch(...){
                      std::cout<<"Error in objfn function evaluation";
                      return sqobjnull;
                  }
                  if(alpha==stepmax){
                      stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
                  }
                  alpha=1;
                  extrap=false;
              }
          }
          if(alpha==stepmax){stepmax=SquaremDefault.mstep*stepmax;}
          if(stepmin<0 && alpha==stepmin){stepmin=SquaremDefault.mstep*stepmin;}
        
          pcpp=pnew;
          if(!std::isnan(lnewcpp)){loldcpp=lnewcpp;}
          if(SquaremDefault.trace){std::cout<<"Objective fn: "<<lnewcpp<<"  Extrapolation: "<<extrap<<"  Steplength: "<<alpha<<std::endl;}
          iter++;
          //std::cout<<"leval="<<leval<<std::endl;//debugging
      }
    
      if (feval >= SquaremDefault.maxiter){conv=false;}
      if (!isfinite(SquaremDefault.objfninc)){loldcpp=objfn(pcpp);leval++;}
    
      //assigning values
      sqobj.par=pcpp;
      sqobj.valueobjfn=loldcpp;
      sqobj.iter=iter;
      sqobj.pfevals=feval;
      sqobj.objfevals=leval;
      sqobj.convergence=conv;
      return(sqobj);
  }


  SquaremOutput squarem2(std::vector<double> par){
      double res,parnorm,kres;
      std::vector<double> pcpp,p1cpp,p2cpp,pnew,ptmp;
      std::vector<double> q1,q2,sr2,sq2,sv2,srv;
      double sr2_scalar,sq2_scalar,sv2_scalar,srv_scalar,alpha,stepmin,stepmax;
      int iter,feval;
      bool conv,extrap;
      stepmin=SquaremDefault.stepmin0;
      stepmax=SquaremDefault.stepmax0;
      if(SquaremDefault.trace){std::cout<<"Squarem-1"<<std::endl;}
    
      iter=1;pcpp=par;pnew=par;
      feval=0;conv=true;
    
      const long int parvectorlength=pcpp.size();
    
      while(feval<SquaremDefault.maxiter){
          //Step 1
          extrap = true;
          try{p1cpp=fixptfn(pcpp);feval++;}
          catch(...){
              std::cout<<"Error in fixptfn function evaluation";
              return sqobjnull;
          }
        
          sr2_scalar=0;
          for (int i=0;i<parvectorlength;i++){sr2_scalar+=pow(p1cpp[i]-pcpp[i],2);}
          if(sqrt(sr2_scalar)<SquaremDefault.tol){break;}
        
          //Step 2
          try{p2cpp=fixptfn(p1cpp);feval++;}
          catch(...){
              std::cout<<"Error in fixptfn function evaluation";
              return sqobjnull;
          }
          sq2_scalar=0;
          for (int i=0;i<parvectorlength;i++){sq2_scalar+=pow(p2cpp[i]-p1cpp[i],2);}
          sq2_scalar=sqrt(sq2_scalar);
          if (sq2_scalar<SquaremDefault.tol){break;}
          res=sq2_scalar;
        
          sv2_scalar=0;
          for (int i=0;i<parvectorlength;i++){sv2_scalar+=pow(p2cpp[i]-2*p1cpp[i]+pcpp[i],2);}
          srv_scalar=0;
          for (int i=0;i<parvectorlength;i++){srv_scalar+=(p2cpp[i]-2*p1cpp[i]+pcpp[i])*(p1cpp[i]-pcpp[i]);}
          //std::cout<<"sr2,sv2,srv="<<sr2_scalar<<","<<sv2_scalar<<","<<srv_scalar<<std::endl;//debugging
        
          //Step 3 Proposing new value
          switch (SquaremDefault.method){
              case 1: alpha= -srv_scalar/sv2_scalar;
              case 2: alpha= -sr2_scalar/srv_scalar;
              case 3: alpha= sqrt(sr2_scalar/sv2_scalar);
          }
        
          alpha=std::max(stepmin,std::min(stepmax,alpha));
          //std::cout<<"alpha="<<alpha<<std::endl;//debugging
          for (int i=0;i<parvectorlength;i++){pnew[i]=pcpp[i]+2.0*alpha*(p1cpp[i]-pcpp[i])+pow(alpha,2)*(p2cpp[i]-2*p1cpp[i]+pcpp[i]);}
          //pnew = pcpp + 2.0*alpha*q1 + alpha*alpha*(q2-q1);
        
          //Step 4 stabilization
          if(std::abs(alpha-1)>0.01){
              try{ptmp=fixptfn(pnew);feval++;}
              catch(...){
                  pnew=p2cpp;
                  if(alpha==stepmax){
                      stepmax=std::max(SquaremDefault.stepmax0,stepmax/SquaremDefault.mstep);
                  }
                  alpha=1;
                  extrap=false;
                  if(alpha==stepmax){stepmax=SquaremDefault.mstep*stepmax;}
                  if(stepmin<0 && alpha==stepmin){stepmin=SquaremDefault.mstep*stepmin;}
                  pcpp=pnew;
                  if(SquaremDefault.trace){std::cout<<"Residual: "<<res<<"  Extrapolation: "<<extrap<<"  Steplength: "<<alpha<<std::endl;}
                  iter++;
                  continue;//next round in while loop
              }
              res=0;
              for (int i=0;i<parvectorlength;i++){res+=pow(ptmp[i]-pnew[i],2);}
              res=sqrt(res);
              parnorm=0;
              for (int i=0;i<parvectorlength;i++){parnorm+=pow(p2cpp[i],2);}
              parnorm=sqrt(parnorm/parvectorlength);
              kres=SquaremDefault.kr*(1+parnorm)+sq2_scalar;
              if(res <= kres){
                  pnew=ptmp;
              }else{
                  pnew=p2cpp;
                  if(alpha==stepmax){stepmax=SquaremDefault.mstep*stepmax;}
                  alpha=1;
                  extrap=false;
              }
          }
        
          if(alpha==stepmax){stepmax=SquaremDefault.mstep*stepmax;}
          if(stepmin<0 && alpha==stepmin){stepmin=SquaremDefault.mstep*stepmin;}
        
          pcpp=pnew;
          if(SquaremDefault.trace){std::cout<<"Residual: "<<res<<"  Extrapolation: "<<extrap<<"  Steplength: "<<alpha<<std::endl;}
          iter++;
      }
    
      if (feval >= SquaremDefault.maxiter){conv=false;}
    
      //assigning values
      sqobj.par=pcpp;
      sqobj.valueobjfn=NAN;
      sqobj.iter=iter;
      sqobj.pfevals=feval;
      sqobj.objfevals=0;
      sqobj.convergence=conv;
      return(sqobj);
  }

  SquaremOutput fpiter(std::vector<double> par){
      //std::vector<double> p,p1,p2;//R data types
      double lnewcpp,res;
      std::vector<double> pcpp,pnew;
      int iter;
      bool conv;
      if(SquaremDefault.trace){std::cout<<"Standaard Fixed Point Iteration:"<<std::endl;}
      iter=1;res=NAN;conv=false;
      pcpp=par;
      const long int parvectorlength=pcpp.size();
      while(iter<SquaremDefault.maxiter*4){
          pnew=fixptfn(pcpp);
          res=0;
          for (int i=0;i<parvectorlength;i++){res+=pow(pnew[i]-pcpp[i],2);}
          res=sqrt(res);
          if(res<SquaremDefault.tol){conv=true;break;}
          if(SquaremDefault.trace){
              if(fmod(iter,100)==0){
                  std::cout<<"Iter: "<<iter<<"Residual: "<<res<<std::endl;
              }
          }
          pcpp=pnew;
          iter++;
      }
    
      lnewcpp=objfn(pcpp);
      //assigning values
      sqobj.par=pcpp;
      sqobj.valueobjfn=lnewcpp;
      sqobj.iter=iter;
      sqobj.pfevals=iter;
      sqobj.objfevals=1;
      sqobj.convergence=conv;
      return(sqobj);
  }


  //main() used for demostration

  std::vector<int> Other_input1 {162,267,271,185,111,61,27,8,3,1};

  int main(){
      std::cout<<"Hi, this is a demostration using Poisson mixture!"<<std::endl;
      std::vector<double> par_initial {0.5,3,1};//some random starting point,
      SquaremOutput SQ_result;
    
      std::cout<<"\n\n\nDemo1: using squarem1 and the objective function"<<endl;
      SQ_result=squarem1(par_initial);
      cout<<"Initial input vector:"<<endl;
      for(int i=0;i<par_initial.size();i++) cout<<par_initial[i]<<" ";
      cout<<"\nOutput vector by SQUAREM:"<<endl;
      for(int i=0;i<par_initial.size();i++) cout<<SQ_result.par[i]<<" ";
      cout<<"\nNumber of evaluations on fixed point function:"<<endl;
      cout<<SQ_result.pfevals<<endl;
      cout<<"Number of evaluations on objective function:"<<endl;
      cout<<SQ_result.objfevals<<endl;
    
      std::cout<<"\n\n\nDemo2: using squarem2 without objective function"<<endl;
      SQ_result=squarem2(par_initial);
      cout<<"Initial input vector:"<<endl;
      for(int i=0;i<par_initial.size();i++) cout<<par_initial[i]<<" ";
      cout<<"\nOutput vector by SQUAREM:"<<endl;
      for(int i=0;i<par_initial.size();i++) cout<<SQ_result.par[i]<<" ";
      cout<<"\nNumber of evaluations on fixed point function:"<<endl;
      cout<<SQ_result.pfevals<<endl;
      cout<<"Number of evaluations on objective function:"<<endl;
      cout<<SQ_result.objfevals<<endl;
    
      std::cout<<"\n\n\nDemo3: using simple fixed point iteration"<<endl;
      SQ_result=fpiter(par_initial);
      cout<<"Initial input vector:"<<endl;
      for(int i=0;i<par_initial.size();i++) cout<<par_initial[i]<<" ";
      cout<<"\nOutput vector by SQUAREM:"<<endl;
      for(int i=0;i<par_initial.size();i++) cout<<SQ_result.par[i]<<" ";
      cout<<"\nNumber of evaluations on fixed point function:"<<endl;
      cout<<SQ_result.pfevals<<endl;
      cout<<"Number of evaluations on objective function:"<<endl;
      cout<<SQ_result.objfevals<<endl;
    
      return 0;
  }


  //Fixed point function and objective function that take only the vector for EM acceleration as input, while others are defined as global variables(const within the scope of cxxSQUAREM)

  vector<double> fixptfn(std::vector<double> par){
      std::vector<double> parnew=par;
    
      std::vector<double> zi(Other_input1.size());
      for (int i=0;i<Other_input1.size();i++){
          zi[i]=par[0]*exp(-par[1])*pow(par[1],i)/(par[0]*exp(-par[1])*pow(par[1],i)+(1-par[0])*exp(-par[2])*pow(par[2],i));
      }
    
    
      double temp1,temp2;
      //parnew[0]=1;
      temp1=0,temp2=0;
      for (int i=0;i<Other_input1.size();i++){
          temp1+=Other_input1[i]*zi[i];
          temp2+=Other_input1[i];
      }
      parnew[0]=temp1/temp2;
    
    
      temp1=0,temp2=0;
      for (int i=0;i<Other_input1.size();i++){
          temp1+=Other_input1[i]*zi[i]*i;
          temp2+=Other_input1[i]*zi[i];
      }
      parnew[1]=temp1/temp2;
    
      temp1=0,temp2=0;
      for (int i=0;i<Other_input1.size();i++){
          temp1+=Other_input1[i]*(1-zi[i])*i;
          temp2+=Other_input1[i]*(1-zi[i]);
      }
      parnew[2]=temp1/temp2;
    
      return parnew;
  }


  double objfn(std::vector<double> par){
      double objvalue=0;
      vector<double> loglik(Other_input1.size());
      for (int i=0;i<Other_input1.size();i++){
          loglik[i]=Other_input1[i]*log(par[0]*exp(-par[1])*pow(par[1],i)/exp(lgamma(i+1))+
                                        (1-par[0])*exp(-par[2])*pow(par[2],i)/exp(lgamma(i+1)));
          objvalue-=loglik[i];
      }
      return objvalue;
  };

#+END_SRC




** Prognostic signatures

#+BEGIN_QUOTE
Based on the FPKM value of each gene, 
patients were classified into two expression groups 
and the correlation between expression level and 
patient survival was examined. 
The prognosis of each group of patients was examined by Kaplan-Meier 
survival estimators, and the survival outcomes of the two groups were 
compared by log-rank tests. Both median and maximally separated 
Kaplan-Meier plots are presented in the Human Protein Atlas, and genes 
with log rank P values less than 0.001 in maximally separated Kaplan-Meier 
analysis were defined as prognostic genes. If the group of patients with 
high expression of a selected prognostic gene has a higher observed event than 
expected event, it is an unfavourable prognostic gene; otherwise, it is a 
favourable prognostic gene. Genes with a median expression less than FPKM 1 
were lowly expressed, and classified as unprognostic in the database even if 
they exhibited significant prognostic effect in survival analysis
#+END_QUOTE


#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ :colnames yes
  library(dplyr)
  library(purrr)
  library(fgem)
  library(readr)
  library(ggplot2)
  library(tidyr)
#+END_SRC


#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
prior_post_plot <- function(name=NULL,log=FALSE,use_null=TRUE){
      tcancer_df <- qs::qread(glue::glue("data/driverMAPS_results_20TumorTypes/{name}.qs"))
      Genes <- tcancer_df$Gene
      BF <- tcancer_df$BF
      fit <- qs::qread(glue::glue("data/models/{name}.qs"))
      tbm <- unnest(fit,data) %>% pull(feature_name)
      go_df <- dplyr::filter(BPGOdf, feature %in% tbm)
      x <- fgem::trip2sparseMatrix(as.character(go_df$Gene),
                                   go_df$feature,
                                   go_df$value,
                                   Genes,
                                   unique(go_df$feature),
                                   add_intercept = TRUE)
      if(use_null){
        unifp <- fgem:::gen_u(fgem:::fgem_null(BF),x[,"Intercept",drop=FALSE],BF,log=log)
      }else{
        unifp <- fgem:::prior_mean(BF,log=log)
      }
      tibble::tibble(Gene=Genes,
                     functional_posterior = predict_fgem(fit, x, BF, log=log),
                     uniform_posterior = unifp)
  }
#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
cancer_map <-tibble::tribble(
                         ~cancer,~cancer_name,
                         "GBM","glioma",
                         "BRCA","breast cancer",
                         "PRAD","prostate cancer",
                         "UCEC", "endometrial cancer",
                         "CESC", "cervical cancer",
                         "BLCA", "urotherial cancer",
                         "LUAD", "lung cancer",
                         "HNSC", "head and neck cancer",
                         "KIRP", "renal cancer",
                         "UCS", NA,
                         "KIRC", "KIRC",
                         "SARC", NA,
                         "SKCM", "melanoma",
                         "LUSC", "lung cancer",
                         "PAAD", "pancreatic cancer",
                         "TGCT", "testis cancer",
                         "ESCA", NA,
                         "LIHC", "liver cancer")


posterior_df <- select(cancer_map,cancer) %>% 
mutate(data=map(cancer,prior_post_plot,log=TRUE)) %>% 
unnest(data)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :session drivermaps :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  

  sfit_df <- unnest(fit,data) %>%
  select(feature=feature_name,Beta)
  sub_BPGO_df <- go_df %>%
  inner_join(nGO_def,by="feature") %>%
  select(-class) %>% 
  mutate(Gene=as.character(Gene))
      pldf <- left_join(plotdf, sub_BPGO_df,by="Gene") %>%
        tidyr::replace_na(list(feature="Intercept",
                               feature_term="None/Other",
                               Term="",
                               value=0L)) %>%
        left_join(sfit_df,by="feature") %>%
        mutate(feature_term=paste0(feature,"\n",Term,"\n", "Beta: ",format(Beta,digits=3)))

      lf <- as_labeller(set_names(pldf$feature_term,pldf$feature))

      ggplot(pldf, aes(x = uniform_posterior, y = functional_posterior, col = feature)) +
        geom_point() + geom_abline(slope=1)+
        facet_wrap(~feature,labeller=lf)+ ggtitle(paste0(name,"\nModel pvalue: ",fit$pval))
    }
#+END_SRC

#+RESULTS:


#+BEGIN_SRC  R :session drivermaps :colnames yes :dir /home/nwknoblauch/Dropbox/Repos/dissertation/ 
  library(ggrepel)
  library(readr)

  prog_cols <- cols(
    ensembl = col_character(),
    Gene = col_character(),
    cancer_name = col_character(),
    High = col_double(),
    Medium = col_double(),
    Low = col_double(),
    Not_detected = col_double(),
    prognostic_favourable = col_double(),
    unprognostic_favourable = col_double(),
    prognostic_unfavourable = col_double(),
    unprognostic_unfavourable = col_double()
  )

  prog_df  <- read_tsv("data/pathology.tsv",skip=1L,col_names=names(prog_cols$cols),col_types=prog_cols) %>%
      select(-ensembl) %>%
      distinct() %>%
      pivot_longer(cols=contains("prognostic")) %>%
      distinct()  %>% separate(name,into=c("isPrognostic","isFavourable"))


      all_prog_df <- inner_join(prog_df,cancer_map) %>%
      select(-cancer_name) %>% group_by(cancer,Gene) %>%
      summarise(prognostic_p=min(value)) %>%
      ungroup()

    ap_df <- distinct(all_prog_df,cancer) %>%
      mutate(data=map(cancer,prior_post_plot)) %>%
      unnest(data) %>%
      left_join(all_prog_df) %>%
      replace_na(list(prognostic_p=1.0)) %>%
      mutate(is_prognostic=prognostic_p<0.01) %>%
      inner_join(model_size) %>%
      filter(model_terms>10)

    plot_l <- split(ap_df,ap_df$cancer) %>% map(~ggplot(.x,aes(x=uniform_posterior,y=functional_posterior,label=Gene,col=is_prognostic))+
                                                  geom_point() +
                                                  geom_text_repel(
                                                    data          = filter(.x, is_prognostic)) +
                                                  geom_abline(slope=1))

    prog_mod <- gather(ap_df, key = "model", value = "posterior",
                       functional_posterior,
                       uniform_posterior) %>%
      mutate(is_prognostic = prognostic_p<0.05) %>% 
      group_by(cancer, model) %>% 
      do(glance(glm(is_prognostic~posterior,
                    data=.,
                    family=binomial()))) %>%
      ungroup()

    select(prog_mod, cancer, model, logLik) %>%
      spread(model,logLik) %>%
      mutate(dev_diff=functional_posterior>uniform_posterior) %>% inner_join(model_size)
#+END_SRC

#+RESULTS:

